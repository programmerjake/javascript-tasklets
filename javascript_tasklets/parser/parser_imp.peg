code license {
/*
 * Copyright (C) 2012-2016 Jacob R. Lifshay
 * This file is part of Voxels.
 *
 * Voxels is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Voxels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Voxels; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 */

// to regenerate this file, use https://github.com/programmerjake/peg_parser_generator
// command: peg_parser_generator parser_imp.peg
}

namespace javascript_tasklets::parser;

code header {
#include "../string.h"

namespace javascript_tasklets
{
namespace parser
{
struct RawAndCookedString final
{
    String raw;
    String cooked;
    RawAndCookedString() : raw(), cooked()
    {
    }
    RawAndCookedString(String raw) : raw(raw), cooked(std::move(raw))
    {
    }
    RawAndCookedString(String raw, String cooked) : raw(std::move(raw)), cooked(std::move(cooked))
    {
    }
};

struct RawStringAndChar final
{
    String raw;
    char32_t ch;
    RawStringAndChar() : raw(), ch()
    {
    }
    RawStringAndChar(String raw, char32_t ch) : raw(std::move(raw)), ch(ch)
    {
    }
};

struct BodyAndFlags final
{
    String body;
    String flags;
    BodyAndFlags() : body(), flags()
    {
    }
    BodyAndFlags(String body, String flags) : body(std::move(body)), flags(std::move(flags))
    {
    }
};
}
}
}

code source {
#include "../character_properties.h"
}

typedef unsigned unsigned;
typedef bool bool;
typedef String String;
typedef RawAndCookedString RawAndCookedString;
typedef RawStringAndChar RawStringAndChar;
typedef BodyAndFlags BodyAndFlags;

TokenizerHexDigitValue:unsigned = 
    [^]:ch
    &{
        auto digitValue = character_properties::javascriptDigitValue(ch);
        if(digitValue >= 0 && digitValue < 0x10)
            $$ = digitValue;
        else
            $? = "missing hex digit";
    };

TokenizerLineTerminatorSequence:char = "\r\n" {$$ = U'\n';}
                                     / "\r" {$$ = U'\n';}
                                     / [^]:char1
                                     &{
                                         $$ = char1;
                                         if(!character_properties::javascriptLineTerminator($$))
                                             $? = "expected a line terminator";
                                     };

TokenizerComment = TokenizerMultiLineComment
                 / TokenizerSingleLineComment;

TokenizerMultiLineComment = "/*" (!"*/" [^])* "*/";

TokenizerMultiLineCommentNoLineTerminator = "/*" (!"*/" !TokenizerLineTerminatorSequence [^])* "*/";

TokenizerSingleLineComment = "//" (!TokenizerLineTerminatorSequence [^])*;

TokenizerUnicodeEscapeSequence:RawStringAndChar = "u" {$$ = RawStringAndChar(u"u", 0);} (
    "{"
    {$$.raw += u"{";}
    (
        [^]:digit
        &{
            auto digitValue = character_properties::javascriptDigitValue(digit);
            if(digitValue < 0 || digitValue >= 0x10)
                $? = "missing hex digit";
            else
            {
                $$.ch = $$.ch * 0x10 + digitValue;
                $$.raw = appendCodePoint(std::move($$.raw), digit);
            }
            if($$.ch > 0x10FFFF)
                $? = "unicode escape value is too big";
        }
    )+
    "}"
    {$$.raw += u"}";}
    / [^]:digit1
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit1);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit1);
          }
      }
      [^]:digit2
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit2);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit2);
          }
      }
      [^]:digit3
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit3);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit3);
          }
      }
      [^]:digit4
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit4);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit4);
          }
      }
    );

TokenizerUnicodeEscapeOrChar:char = "\\" TokenizerUnicodeEscapeSequence:escape {$$ = escape.ch;}
                                  / [^]:ch {$$ = ch;};

TokenizerEscapelessIdentifierStart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdStart(ch))
            $? = "expected identifier start";
        else
            $$ = ch;
    };

TokenizerEscapelessIdentifierPart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdContinue(ch))
            $? = "expected identifier part";
        else
            $$ = ch;
    };

TokenizerIdentifierName:String =
    TokenizerUnicodeEscapeOrChar:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = startChar;
    }
    (
        TokenizerUnicodeEscapeOrChar:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = continueChar;
        }
    )*
    !"\\";

TokenizerEscapelessIdentifierName:String =
    [^]:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = appendCodePoint(u"", startChar);
    }
    (
        [^]:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = appendCodePoint(std::move($$), continueChar);
        }
    )*
    !"\\";

TokenizerReservedWord<isModule:bool, isStrict:bool> = TokenizerKeyword / TokenizerFutureReservedWord / TokenizerNullLiteral / TokenizerBooleanLiteral;

TokenizerAwait = "await" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerBreak = "break" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCase = "case" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCatch = "catch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerClass = "class" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerConst = "const" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerContinue = "continue" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDebugger = "debugger" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDefault = "default" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDelete = "delete" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDo = "do" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerElse = "else" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerEnum = "enum" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExport = "export" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExtends = "extends" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFalse = "false" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFinally = "finally" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFor = "for" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFunction = "function" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIf = "if" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImplements = "implements" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImport = "import" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIn = "in" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInstanceOf = "instanceof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInterface = "interface" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNew = "new" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNull = "null" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPackage = "package" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPrivate = "private" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerProtected = "protected" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPublic = "public" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerReturn = "return" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSuper = "super" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSwitch = "switch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThis = "this" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThrow = "throw" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTrue = "true" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTry = "try" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTypeOf = "typeof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVar = "var" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVoid = "void" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWhile = "while" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWith = "with" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerYield = "yield" !"\\" !TokenizerEscapelessIdentifierPart;

TokenizerKeyword = TokenizerBreak
                 / TokenizerCase
                 / TokenizerCatch
                 / TokenizerClass
                 / TokenizerConst
                 / TokenizerContinue
                 / TokenizerDebugger
                 / TokenizerDefault
                 / TokenizerDelete
                 / TokenizerDo
                 / TokenizerElse
                 / TokenizerExport
                 / TokenizerExtends
                 / TokenizerFinally
                 / TokenizerFor
                 / TokenizerFunction
                 / TokenizerIf
                 / TokenizerImport
                 / TokenizerIn
                 / TokenizerInstanceOf
                 / TokenizerNew
                 / TokenizerReturn
                 / TokenizerSuper
                 / TokenizerSwitch
                 / TokenizerThis
                 / TokenizerThrow
                 / TokenizerTry
                 / TokenizerTypeOf
                 / TokenizerVar
                 / TokenizerVoid
                 / TokenizerWhile
                 / TokenizerWith
                 / TokenizerYield;

TokenizerFutureReservedWord<isModule:bool, isStrict:bool> =
    TokenizerAwait &{if(isModule) $? = "not in a module";}
    / TokenizerEnum
    / &{if(!isStrict) $? = "not strict";}
    (
        TokenizerImplements
        / TokenizerInterface
        / TokenizerPackage
        / TokenizerPrivate
        / TokenizerProtected
        / TokenizerPublic
    );

TokenizerNullLiteral = TokenizerNull;

TokenizerBooleanLiteral:bool = TokenizerTrue {$$ = true;} / TokenizerFalse {$$ = false;};

TokenizerLBrace = "{";
TokenizerRBrace = "}";
TokenizerLParen = "(";
TokenizerRParen = ")";
TokenizerLBracket = "[";
TokenizerRBracket = "]";
TokenizerPeriod = !"..." "." ![0-9];
TokenizerEllipsis = "...";
TokenizerSemicolon = ";";
TokenizerComma = ",";
TokenizerLAngle = "<" ![<=];
TokenizerRAngle = ">" ![>=];
TokenizerLAngleEqual = "<=";
TokenizerRAngleEqual = ">=";
TokenizerEqualEqual = "==" !"=";
TokenizerEMarkEqual = "!=" !"=";
TokenizerEqualEqualEqual = "===";
TokenizerEMarkEqualEqual = "!==";
TokenizerPlus = "+" ![+=];
TokenizerMinus = "-" ![\-=];
TokenizerStar = "*" ![*=];
TokenizerStarStar = "**";
TokenizerPercent = "%" !"=";
TokenizerPlusPlus = "++";
TokenizerMinusMinus = "--";
TokenizerLAngleLAngle = "<<" !"=";
TokenizerRAngleRAngle = ">>" ![>=];
TokenizerRAngleRAngleRAngle = ">>>" !"=";
TokenizerAmp = "&" ![&=];
TokenizerPipe = "|" ![|=];
TokenizerCaret = "^" !"=";
TokenizerEMark = "!" !"=";
TokenizerTilde = "~";
TokenizerAmpAmp = "&&";
TokenizerPipePipe = "||";
TokenizerQMark = "?";
TokenizerColon = ":";
TokenizerEqual = "=" ![=>];
TokenizerPlusEqual = "+=";
TokenizerMinusEqual = "-=";
TokenizerStarEqual = "*=";
TokenizerPercentEqual = "%=";
TokenizerLAngleLAngleEqual = "<<=";
TokenizerRAngleRAngleEqual = ">>=";
TokenizerRAngleRAngleRAngleEqual = ">>>=";
TokenizerAmpEqual = "&=";
TokenizerPipeEqual = "|=";
TokenizerCaretEqual = "^=";
TokenizerArrow = "=>";
TokenizerFSlash = "/" ![=/*];
TokenizerFSlashEqual = "/=";

TokenizerPunctuator = TokenizerLBrace
                    / TokenizerLParen
                    / TokenizerRParen
                    / TokenizerLBracket
                    / TokenizerRBracket
                    / TokenizerPeriod
                    / TokenizerEllipsis
                    / TokenizerSemicolon
                    / TokenizerComma
                    / TokenizerLAngle
                    / TokenizerRAngle
                    / TokenizerLAngleEqual
                    / TokenizerRAngleEqual
                    / TokenizerEqualEqual
                    / TokenizerEMarkEqual
                    / TokenizerEqualEqualEqual
                    / TokenizerEMarkEqualEqual
                    / TokenizerPlus
                    / TokenizerMinus
                    / TokenizerStar
                    / TokenizerStarStar
                    / TokenizerPercent
                    / TokenizerPlusPlus
                    / TokenizerMinusMinus
                    / TokenizerLAngleLAngle
                    / TokenizerRAngleRAngle
                    / TokenizerRAngleRAngleRAngle
                    / TokenizerAmp
                    / TokenizerPipe
                    / TokenizerCaret
                    / TokenizerEMark
                    / TokenizerTilde
                    / TokenizerAmpAmp
                    / TokenizerPipePipe
                    / TokenizerQMark
                    / TokenizerColon
                    / TokenizerEqual
                    / TokenizerPlusEqual
                    / TokenizerMinusEqual
                    / TokenizerStarEqual
                    / TokenizerPercentEqual
                    / TokenizerLAngleLAngleEqual
                    / TokenizerRAngleRAngleEqual
                    / TokenizerRAngleRAngleRAngleEqual
                    / TokenizerAmpEqual
                    / TokenizerPipeEqual
                    / TokenizerCaretEqual
                    / TokenizerArrow;

TokenizerDivPunctuator = TokenizerFSlash / TokenizerFSlashEqual;

TokenizerRightBracePunctuator = TokenizerRBrace;

TokenizerNumericLiteral:String = TokenizerDecimalLiteral:value0 {$$ = value0;}
                               / TokenizerBinaryIntegerLiteral:value1 {$$ = value1;}
                               / TokenizerOctalIntegerLiteral:value2 {$$ = value2;}
                               / TokenizerHexIntegerLiteral:value3 {$$ = value3;};

TokenizerDecimalLiteral:String = TokenizerDecimalIntegerLiteral:value0 {$$ = value0;}
                                 "." {$$ += u'.';}
                                 (
                                     TokenizerDecimalDigits:value1 {$$ += value1;}
                                 )?
                                 (
                                     TokenizerExponentPart:value2 {$$ += value2;}
                                 )?
                               / "." {$$ = u'.';}
                                 TokenizerDecimalDigits:value3 {$$ += value3;}
                                 (
                                     TokenizerExponentPart:value4 {$$ += value4;}
                                 )?
                               / TokenizerDecimalIntegerLiteral:value5 {$$ = value5;}
                                 TokenizerDecimalDigits:value6 {$$ += value6;}
                                 (
                                     TokenizerExponentPart:value7 {$$ += value7;}
                                 )?
                               ;

TokenizerDecimalIntegerLiteral:String =
    "0" {$$ = u"0";} ![0-9]
    / [1-9]:nonZeroDigit
    {$$ = appendCodePoint(u"", nonZeroDigit);}
    (TokenizerDecimalDigits:digits {$$ += digits;})?;

TokenizerDecimalDigits:String =
    {$$ = u"";}
    (
        [0-9]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerExponentPart:String =
    [eE]:exponentIndicator
    {$$ = appendCodePoint(u"", exponentIndicator);}
    TokenizerSignedInteger:signedInteger
    {$$ += signedInteger;}
    ;

TokenizerSignedInteger:String =
    {$$ = u"";}
    (
        [+\-]:sign
        {$$ = appendCodePoint(u"", sign);}
    )?
    TokenizerDecimalDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [bB]:binaryIndicator
    {$$ = appendCodePoint(std::move($$), binaryIndicator);}
    TokenizerBinaryDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryDigits:String =
    {$$ = u"";}
    (
        [01]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerOctalIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [oO]:octalIndicator
    {$$ = appendCodePoint(std::move($$), octalIndicator);}
    TokenizerOctalDigits:digits
    {$$ += digits;}
    ;

TokenizerOctalDigits:String =
    {$$ = u"";}
    (
        [0-7]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerHexIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [xX]:hexIndicator
    {$$ = appendCodePoint(std::move($$), hexIndicator);}
    TokenizerHexDigits:digits
    {$$ += digits;}
    ;

TokenizerHexDigits:String =
    {$$ = u"";}
    (
        [0-9a-fA-F]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerStringLiteral:String =
    "\'"
    {$$ = u"";}
    (
        TokenizerSingleStringCharacters:characters1
        {$$ = characters1;}
    )?
    "\'"
    / "\""
    {$$ = u"";}
    (
        TokenizerDoubleStringCharacters:characters2
        {$$ = characters2;}
    )?
    "\"";

TokenizerSingleStringCharacters:String =
    TokenizerSingleStringCharacter:first
    {$$ = first;}
    (
        TokenizerSingleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerDoubleStringCharacters:String =
    TokenizerDoubleStringCharacter:first
    {$$ = first;}
    (
        TokenizerDoubleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerSingleStringCharacter:String =
    !"\'"
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerDoubleStringCharacter:String =
    !"\""
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerLineContinuation:String = "\\" TokenizerLineTerminatorSequence:lineTerminator {$$ = appendCodePoint(u"\\", lineTerminator);};

TokenizerEscapeSequence:RawAndCookedString =
    "0"
    ![0-9]
    {$$ = RawAndCookedString(u"0", String(1, u'\0'));}
    / TokenizerCharacterEscapeSequence:characterEscape
    {$$ = characterEscape;}
    / TokenizerUnicodeEscapeSequence:unicodeEscape
    {$$ = RawAndCookedString(unicodeEscape.raw, appendCodePoint(u"", unicodeEscape.ch));}
    / TokenizerHexEscapeSequence:hexEscape
    {$$ = RawAndCookedString(hexEscape.raw, appendCodePoint(u"", hexEscape.ch));}
    ;

TokenizerHexEscapeSequence:RawStringAndChar = 
    "x"
    {$$ = RawStringAndChar(u"x", 0);}
    [^]:digit1
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit1);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit1);
        }
    }
    [^]:digit2
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit2);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit2);
        }
    }
    ;

TokenizerCharacterEscapeSequence:RawAndCookedString =
    TokenizerSingleEscapeCharacter:singleEscapeCharacter
    {$$ = singleEscapeCharacter;}
    / TokenizerNonEscapeCharacter:nonEscapeCharacter
    {$$ = RawAndCookedString(appendCodePoint(u"", nonEscapeCharacter));}
    ;

TokenizerSingleEscapeCharacter:RawAndCookedString =
    ['"\\]:char1
    {$$ = RawAndCookedString(appendCodePoint(u"", char1));}
    / "b"
    {$$ = RawAndCookedString(u"b", u"\b");}
    / "f"
    {$$ = RawAndCookedString(u"f", u"\f");}
    / "n"
    {$$ = RawAndCookedString(u"n", u"\n");}
    / "r"
    {$$ = RawAndCookedString(u"r", u"\r");}
    / "t"
    {$$ = RawAndCookedString(u"t", u"\t");}
    / "v"
    {$$ = RawAndCookedString(u"v", u"\v");}
    ;

TokenizerNonEscapeCharacter:char =
    !TokenizerLineTerminatorSequence
    ![0-9xu]
    !TokenizerSingleEscapeCharacter
    [^]:ch
    {$$ = ch;}
    ;

TokenizerRegularExpressionLiteral:BodyAndFlags =
    "/"
    TokenizerRegularExpressionBody:body
    "/"
    TokenizerRegularExpressionFlags:flags
    {$$ = BodyAndFlags(body, flags);};

TokenizerRegularExpressionBody:String =
    !"*"
    {$$ = u"";}
    (
        TokenizerRegularExpressionChar:value
        {$$ += value;}
    )+;

TokenizerRegularExpressionChar:String =
    ![\\/[]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    / TokenizerRegularExpressionClass:classValue
    {$$ = classValue;}
    ;

TokenizerRegularExpressionBackslashSequence:String =
    "\\"
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"\\", nonTerminator);}
    ;

TokenizerRegularExpressionClass:String =
    "["
    {$$ = u"[";}
    (
        TokenizerRegularExpressionClassChar:classChar
        {$$ += classChar;}
    )*
    "]"
    {$$ += u"]";}
    ;

TokenizerRegularExpressionClassChar:String =
    ![\\\]]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    ;

TokenizerRegularExpressionFlags:String =
    {$$ = u"";}
    (
        TokenizerEscapelessIdentifierPart:ch
        {$$ = appendCodePoint(std::move($$), ch);}
        / "\\"
        TokenizerUnicodeEscapeSequence:unicodeEscape
        {$$ += u"\\" + unicodeEscape.raw;}
    )*
    !"\\"
    ;

TokenizerNoSubstitutionTemplate:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateHead:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateMiddle:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateTail:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateCharacter:RawAndCookedString =
    "$"
    !"{"
    {$$ = RawAndCookedString(u"$");}
    / "\\"
    TokenizerEscapeSequence:escapeSequence
    {$$.raw += u"\\" + escapeSequence.raw; $$.cooked += escapeSequence.cooked;}
    / "\\"
    TokenizerLineTerminatorSequence:lineContinuation
    {$$.raw = appendCodePoint(std::move($$.raw) + u"\\", lineContinuation);}
    / TokenizerLineTerminatorSequence:lineTerminator
    {
        $$.raw = appendCodePoint(std::move($$.raw), lineTerminator);
        $$.cooked = appendCodePoint(std::move($$.cooked), lineTerminator);
    }
    / !TokenizerLineTerminatorSequence
    [^`\\$]:ch
    {
        $$.raw = appendCodePoint(std::move($$.raw), ch);
        $$.cooked = appendCodePoint(std::move($$.cooked), ch);
    }
    ;

    