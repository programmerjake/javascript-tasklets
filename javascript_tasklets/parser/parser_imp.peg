code license {
/*
 * Copyright (C) 2012-2016 Jacob R. Lifshay
 * This file is part of Voxels.
 *
 * Voxels is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Voxels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Voxels; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 */

// to regenerate this file, use https://github.com/programmerjake/peg_parser_generator
// command: peg_parser_generator parser_imp.peg
}

namespace javascript_tasklets::parser;

code header {
#include "../string.h"
#include <memory>
#include <vector>
#include "ast/node.h"
#include "ast/expression.h"
#include "ast/literal.h"
#include "ast/arena.h"

namespace javascript_tasklets
{
namespace parser
{
struct RawAndCookedString final
{
    String raw;
    String cooked;
    RawAndCookedString() : raw(), cooked()
    {
    }
    RawAndCookedString(String raw) : raw(raw), cooked(std::move(raw))
    {
    }
    RawAndCookedString(String raw, String cooked) : raw(std::move(raw)), cooked(std::move(cooked))
    {
    }
};

struct RawStringAndChar final
{
    String raw;
    char32_t ch;
    RawStringAndChar() : raw(), ch()
    {
    }
    RawStringAndChar(String raw, char32_t ch) : raw(std::move(raw)), ch(ch)
    {
    }
};

struct BodyAndFlags final
{
    String body;
    String flags;
    BodyAndFlags() : body(), flags()
    {
    }
    BodyAndFlags(String body, String flags) : body(std::move(body)), flags(std::move(flags))
    {
    }
};

typedef ast::Node *NodePointer;
typedef ast::Expression *ExpressionPointer;
typedef ast::ArrayLiteralElement *ArrayLiteralElementPointer;
typedef std::vector<ast::ArrayLiteralElement *> ArrayLiteralElementList;
}
}
}

code class {
public:
    ast::Arena arena = ast::Arena();
}

code source {
#include "../character_properties.h"
#include "ast/expressions.h"
#include "../value.h"
}

typedef unsigned unsigned;
typedef bool bool;
typedef String String;
typedef RawAndCookedString RawAndCookedString;
typedef RawStringAndChar RawStringAndChar;
typedef BodyAndFlags BodyAndFlags;
typedef ExpressionPointer ExpressionPointer;
typedef NodePointer NodePointer;
typedef ArrayLiteralElementPointer ArrayLiteralElementPointer;
typedef ArrayLiteralElementList ArrayLiteralElementList;
typedef ast::TemplateRest TemplateRest;

TokenizerHexDigitValue:unsigned = 
    [^]:ch
    &{
        auto digitValue = character_properties::javascriptDigitValue(ch);
        if(digitValue >= 0 && digitValue < 0x10)
            $$ = digitValue;
        else
            $? = "missing hex digit";
    };

TokenizerLineTerminatorSequence:char = "\r\n" {$$ = U'\n';}
                                     / "\r" {$$ = U'\n';}
                                     / [^]:char1
                                     &{
                                         $$ = char1;
                                         if(!character_properties::javascriptLineTerminator($$))
                                             $? = "expected a line terminator";
                                     };

TokenizerComment<lineTerminatorAllowed:bool> =
    TokenizerMultiLineComment
    / TokenizerSingleLineComment;

TokenizerMultiLineComment<lineTerminatorAllowed:bool>:bool =
    "/*"
    {$$ = false;}
    (
        !"*/"
        (
            TokenizerLineTerminatorSequence
            &{
                if(!lineTerminatorAllowed)
                    $? = "line terminator not allowed here";
                $$ = true;
            }
            / !TokenizerLineTerminatorSequence
            [^]
        )
    )*
    "*/";

TokenizerSingleLineComment = "//" (!TokenizerLineTerminatorSequence [^])*;

TokenizerTokenSeperator<lineTerminatorAllowed:bool> = 
    (
        TokenizerMultiLineComment
        / TokenizerSingleLineComment
        / TokenizerLineTerminatorSequence
        &{
            if(!lineTerminatorAllowed)
                $? = "line terminator not allowed here";
        }
        / !TokenizerLineTerminatorSequence
        [^]:ch
        &{
            if(!character_properties::javascriptWhiteSpace(ch))
                $? = "not a whitespace character";
        }
    )*;

TokenizerTokenSeperatorWithLineTerminator = 
    TokenizerTokenSeperator<false>
    (
        TokenizerMultiLineComment<true>:hasLineTerminator
        &{
            if(!hasLineTerminator)
                $? = "missing line terminator";
        }
        / TokenizerLineTerminatorSequence
    );
        

TokenizerUnicodeEscapeSequence:RawStringAndChar = "u" {$$ = RawStringAndChar(u"u", 0);} (
    "{"
    {$$.raw += u"{";}
    (
        [^]:digit
        &{
            auto digitValue = character_properties::javascriptDigitValue(digit);
            if(digitValue < 0 || digitValue >= 0x10)
                $? = "missing hex digit";
            else
            {
                $$.ch = $$.ch * 0x10 + digitValue;
                $$.raw = appendCodePoint(std::move($$.raw), digit);
            }
            if($$.ch > 0x10FFFF)
                $? = "unicode escape value is too big";
        }
    )+
    "}"
    {$$.raw += u"}";}
    / [^]:digit1
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit1);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit1);
          }
      }
      [^]:digit2
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit2);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit2);
          }
      }
      [^]:digit3
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit3);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit3);
          }
      }
      [^]:digit4
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit4);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit4);
          }
      }
    );

TokenizerUnicodeEscapeOrChar:char = "\\" TokenizerUnicodeEscapeSequence:escape {$$ = escape.ch;}
                                  / [^]:ch {$$ = ch;};

TokenizerEscapelessIdentifierStart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdStart(ch))
            $? = "expected identifier start";
        else
            $$ = ch;
    };

TokenizerEscapelessIdentifierPart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdContinue(ch))
            $? = "expected identifier part";
        else
            $$ = ch;
    };

TokenizerIdentifierName:String =
    TokenizerUnicodeEscapeOrChar:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = startChar;
    }
    (
        TokenizerUnicodeEscapeOrChar:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = continueChar;
        }
    )*
    !"\\";

TokenizerEscapelessIdentifierName:String =
    [^]:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = appendCodePoint(u"", startChar);
    }
    (
        [^]:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = appendCodePoint(std::move($$), continueChar);
        }
    )*
    !"\\";

TokenizerReservedWord<isModule:bool, isStrict:bool> = TokenizerKeyword / TokenizerFutureReservedWord / TokenizerNullLiteral / TokenizerBooleanLiteral;

TokenizerAwait = "await" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerBreak = "break" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCase = "case" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCatch = "catch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerClass = "class" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerConst = "const" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerContinue = "continue" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDebugger = "debugger" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDefault = "default" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDelete = "delete" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDo = "do" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerElse = "else" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerEnum = "enum" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExport = "export" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExtends = "extends" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFalse = "false" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFinally = "finally" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFor = "for" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFunction = "function" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIf = "if" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImplements = "implements" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImport = "import" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIn = "in" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInstanceOf = "instanceof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInterface = "interface" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNew = "new" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNull = "null" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPackage = "package" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPrivate = "private" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerProtected = "protected" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPublic = "public" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerReturn = "return" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSuper = "super" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSwitch = "switch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThis = "this" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThrow = "throw" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTrue = "true" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTry = "try" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTypeOf = "typeof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVar = "var" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVoid = "void" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWhile = "while" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWith = "with" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerYield = "yield" !"\\" !TokenizerEscapelessIdentifierPart;

TokenizerKeyword = TokenizerBreak
                 / TokenizerCase
                 / TokenizerCatch
                 / TokenizerClass
                 / TokenizerConst
                 / TokenizerContinue
                 / TokenizerDebugger
                 / TokenizerDefault
                 / TokenizerDelete
                 / TokenizerDo
                 / TokenizerElse
                 / TokenizerExport
                 / TokenizerExtends
                 / TokenizerFinally
                 / TokenizerFor
                 / TokenizerFunction
                 / TokenizerIf
                 / TokenizerImport
                 / TokenizerIn
                 / TokenizerInstanceOf
                 / TokenizerNew
                 / TokenizerReturn
                 / TokenizerSuper
                 / TokenizerSwitch
                 / TokenizerThis
                 / TokenizerThrow
                 / TokenizerTry
                 / TokenizerTypeOf
                 / TokenizerVar
                 / TokenizerVoid
                 / TokenizerWhile
                 / TokenizerWith
                 / TokenizerYield;

TokenizerFutureReservedWord<isModule:bool, isStrict:bool> =
    TokenizerAwait &{if(isModule) $? = "not in a module";}
    / TokenizerEnum
    / &{if(!isStrict) $? = "not strict";}
    (
        TokenizerImplements
        / TokenizerInterface
        / TokenizerPackage
        / TokenizerPrivate
        / TokenizerProtected
        / TokenizerPublic
    );

TokenizerNullLiteral = TokenizerNull;

TokenizerBooleanLiteral:bool = TokenizerTrue {$$ = true;} / TokenizerFalse {$$ = false;};

TokenizerLBrace = "{";
TokenizerRBrace = "}";
TokenizerLParen = "(";
TokenizerRParen = ")";
TokenizerLBracket = "[";
TokenizerRBracket = "]";
TokenizerPeriod = !"..." "." ![0-9];
TokenizerEllipsis = "...";
TokenizerSemicolon = ";";
TokenizerComma = ",";
TokenizerLAngle = "<" ![<=];
TokenizerRAngle = ">" ![>=];
TokenizerLAngleEqual = "<=";
TokenizerRAngleEqual = ">=";
TokenizerEqualEqual = "==" !"=";
TokenizerEMarkEqual = "!=" !"=";
TokenizerEqualEqualEqual = "===";
TokenizerEMarkEqualEqual = "!==";
TokenizerPlus = "+" ![+=];
TokenizerMinus = "-" ![\-=];
TokenizerStar = "*" ![*=];
TokenizerStarStar = "**";
TokenizerPercent = "%" !"=";
TokenizerPlusPlus = "++";
TokenizerMinusMinus = "--";
TokenizerLAngleLAngle = "<<" !"=";
TokenizerRAngleRAngle = ">>" ![>=];
TokenizerRAngleRAngleRAngle = ">>>" !"=";
TokenizerAmp = "&" ![&=];
TokenizerPipe = "|" ![|=];
TokenizerCaret = "^" !"=";
TokenizerEMark = "!" !"=";
TokenizerTilde = "~";
TokenizerAmpAmp = "&&";
TokenizerPipePipe = "||";
TokenizerQMark = "?";
TokenizerColon = ":";
TokenizerEqual = "=" ![=>];
TokenizerPlusEqual = "+=";
TokenizerMinusEqual = "-=";
TokenizerStarEqual = "*=";
TokenizerPercentEqual = "%=";
TokenizerLAngleLAngleEqual = "<<=";
TokenizerRAngleRAngleEqual = ">>=";
TokenizerRAngleRAngleRAngleEqual = ">>>=";
TokenizerAmpEqual = "&=";
TokenizerPipeEqual = "|=";
TokenizerCaretEqual = "^=";
TokenizerArrow = "=>";
TokenizerFSlash = "/" ![=/*];
TokenizerFSlashEqual = "/=";

TokenizerPunctuator = TokenizerLBrace
                    / TokenizerLParen
                    / TokenizerRParen
                    / TokenizerLBracket
                    / TokenizerRBracket
                    / TokenizerPeriod
                    / TokenizerEllipsis
                    / TokenizerSemicolon
                    / TokenizerComma
                    / TokenizerLAngle
                    / TokenizerRAngle
                    / TokenizerLAngleEqual
                    / TokenizerRAngleEqual
                    / TokenizerEqualEqual
                    / TokenizerEMarkEqual
                    / TokenizerEqualEqualEqual
                    / TokenizerEMarkEqualEqual
                    / TokenizerPlus
                    / TokenizerMinus
                    / TokenizerStar
                    / TokenizerStarStar
                    / TokenizerPercent
                    / TokenizerPlusPlus
                    / TokenizerMinusMinus
                    / TokenizerLAngleLAngle
                    / TokenizerRAngleRAngle
                    / TokenizerRAngleRAngleRAngle
                    / TokenizerAmp
                    / TokenizerPipe
                    / TokenizerCaret
                    / TokenizerEMark
                    / TokenizerTilde
                    / TokenizerAmpAmp
                    / TokenizerPipePipe
                    / TokenizerQMark
                    / TokenizerColon
                    / TokenizerEqual
                    / TokenizerPlusEqual
                    / TokenizerMinusEqual
                    / TokenizerStarEqual
                    / TokenizerPercentEqual
                    / TokenizerLAngleLAngleEqual
                    / TokenizerRAngleRAngleEqual
                    / TokenizerRAngleRAngleRAngleEqual
                    / TokenizerAmpEqual
                    / TokenizerPipeEqual
                    / TokenizerCaretEqual
                    / TokenizerArrow;

TokenizerDivPunctuator = TokenizerFSlash / TokenizerFSlashEqual;

TokenizerRightBracePunctuator = TokenizerRBrace;

TokenizerNumericLiteral:String = TokenizerDecimalLiteral:value0 {$$ = value0;}
                               / TokenizerBinaryIntegerLiteral:value1 {$$ = value1;}
                               / TokenizerOctalIntegerLiteral:value2 {$$ = value2;}
                               / TokenizerHexIntegerLiteral:value3 {$$ = value3;};

TokenizerDecimalLiteral:String = TokenizerDecimalIntegerLiteral:value0 {$$ = value0;}
                                 "." {$$ += u'.';}
                                 (
                                     TokenizerDecimalDigits:value1 {$$ += value1;}
                                 )?
                                 (
                                     TokenizerExponentPart:value2 {$$ += value2;}
                                 )?
                               / "." {$$ = u'.';}
                                 TokenizerDecimalDigits:value3 {$$ += value3;}
                                 (
                                     TokenizerExponentPart:value4 {$$ += value4;}
                                 )?
                               / TokenizerDecimalIntegerLiteral:value5 {$$ = value5;}
                                 TokenizerDecimalDigits:value6 {$$ += value6;}
                                 (
                                     TokenizerExponentPart:value7 {$$ += value7;}
                                 )?
                               ;

TokenizerDecimalIntegerLiteral:String =
    "0" {$$ = u"0";} ![0-9]
    / [1-9]:nonZeroDigit
    {$$ = appendCodePoint(u"", nonZeroDigit);}
    (TokenizerDecimalDigits:digits {$$ += digits;})?;

TokenizerDecimalDigits:String =
    {$$ = u"";}
    (
        [0-9]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerExponentPart:String =
    [eE]:exponentIndicator
    {$$ = appendCodePoint(u"", exponentIndicator);}
    TokenizerSignedInteger:signedInteger
    {$$ += signedInteger;}
    ;

TokenizerSignedInteger:String =
    {$$ = u"";}
    (
        [+\-]:sign
        {$$ = appendCodePoint(u"", sign);}
    )?
    TokenizerDecimalDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [bB]:binaryIndicator
    {$$ = appendCodePoint(std::move($$), binaryIndicator);}
    TokenizerBinaryDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryDigits:String =
    {$$ = u"";}
    (
        [01]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerOctalIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [oO]:octalIndicator
    {$$ = appendCodePoint(std::move($$), octalIndicator);}
    TokenizerOctalDigits:digits
    {$$ += digits;}
    ;

TokenizerOctalDigits:String =
    {$$ = u"";}
    (
        [0-7]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerHexIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [xX]:hexIndicator
    {$$ = appendCodePoint(std::move($$), hexIndicator);}
    TokenizerHexDigits:digits
    {$$ += digits;}
    ;

TokenizerHexDigits:String =
    {$$ = u"";}
    (
        [0-9a-fA-F]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerStringLiteral:String =
    "\'"
    {$$ = u"";}
    (
        TokenizerSingleStringCharacters:characters1
        {$$ = characters1;}
    )?
    "\'"
    / "\""
    {$$ = u"";}
    (
        TokenizerDoubleStringCharacters:characters2
        {$$ = characters2;}
    )?
    "\"";

TokenizerSingleStringCharacters:String =
    TokenizerSingleStringCharacter:first
    {$$ = first;}
    (
        TokenizerSingleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerDoubleStringCharacters:String =
    TokenizerDoubleStringCharacter:first
    {$$ = first;}
    (
        TokenizerDoubleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerSingleStringCharacter:String =
    !"\'"
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerDoubleStringCharacter:String =
    !"\""
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerLineContinuation:String = "\\" TokenizerLineTerminatorSequence:lineTerminator {$$ = appendCodePoint(u"\\", lineTerminator);};

TokenizerEscapeSequence:RawAndCookedString =
    "0"
    ![0-9]
    {$$ = RawAndCookedString(u"0", String(1, u'\0'));}
    / TokenizerCharacterEscapeSequence:characterEscape
    {$$ = characterEscape;}
    / TokenizerUnicodeEscapeSequence:unicodeEscape
    {$$ = RawAndCookedString(unicodeEscape.raw, appendCodePoint(u"", unicodeEscape.ch));}
    / TokenizerHexEscapeSequence:hexEscape
    {$$ = RawAndCookedString(hexEscape.raw, appendCodePoint(u"", hexEscape.ch));}
    ;

TokenizerHexEscapeSequence:RawStringAndChar = 
    "x"
    {$$ = RawStringAndChar(u"x", 0);}
    [^]:digit1
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit1);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit1);
        }
    }
    [^]:digit2
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit2);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit2);
        }
    }
    ;

TokenizerCharacterEscapeSequence:RawAndCookedString =
    TokenizerSingleEscapeCharacter:singleEscapeCharacter
    {$$ = singleEscapeCharacter;}
    / TokenizerNonEscapeCharacter:nonEscapeCharacter
    {$$ = RawAndCookedString(appendCodePoint(u"", nonEscapeCharacter));}
    ;

TokenizerSingleEscapeCharacter:RawAndCookedString =
    ['"\\]:char1
    {$$ = RawAndCookedString(appendCodePoint(u"", char1));}
    / "b"
    {$$ = RawAndCookedString(u"b", u"\b");}
    / "f"
    {$$ = RawAndCookedString(u"f", u"\f");}
    / "n"
    {$$ = RawAndCookedString(u"n", u"\n");}
    / "r"
    {$$ = RawAndCookedString(u"r", u"\r");}
    / "t"
    {$$ = RawAndCookedString(u"t", u"\t");}
    / "v"
    {$$ = RawAndCookedString(u"v", u"\v");}
    ;

TokenizerNonEscapeCharacter:char =
    !TokenizerLineTerminatorSequence
    ![0-9xu]
    !TokenizerSingleEscapeCharacter
    [^]:ch
    {$$ = ch;}
    ;

TokenizerRegularExpressionLiteral:BodyAndFlags =
    "/"
    TokenizerRegularExpressionBody:body
    "/"
    TokenizerRegularExpressionFlags:flags
    {$$ = BodyAndFlags(body, flags);};

TokenizerRegularExpressionBody:String =
    !"*"
    {$$ = u"";}
    (
        TokenizerRegularExpressionChar:value
        {$$ += value;}
    )+;

TokenizerRegularExpressionChar:String =
    ![\\/[]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    / TokenizerRegularExpressionClass:classValue
    {$$ = classValue;}
    ;

TokenizerRegularExpressionBackslashSequence:String =
    "\\"
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"\\", nonTerminator);}
    ;

TokenizerRegularExpressionClass:String =
    "["
    {$$ = u"[";}
    (
        TokenizerRegularExpressionClassChar:classChar
        {$$ += classChar;}
    )*
    "]"
    {$$ += u"]";}
    ;

TokenizerRegularExpressionClassChar:String =
    ![\\\]]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    ;

TokenizerRegularExpressionFlags:String =
    {$$ = u"";}
    (
        TokenizerEscapelessIdentifierPart:ch
        {$$ = appendCodePoint(std::move($$), ch);}
        / "\\"
        TokenizerUnicodeEscapeSequence:unicodeEscape
        {$$ += u"\\" + unicodeEscape.raw;}
    )*
    !"\\"
    ;

TokenizerNoSubstitutionTemplate:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateHead:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateMiddle:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateTail:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateCharacter:RawAndCookedString =
    "$"
    !"{"
    {$$ = RawAndCookedString(u"$");}
    / "\\"
    TokenizerEscapeSequence:escapeSequence
    {$$.raw += u"\\" + escapeSequence.raw; $$.cooked += escapeSequence.cooked;}
    / "\\"
    TokenizerLineTerminatorSequence:lineContinuation
    {$$.raw = appendCodePoint(std::move($$.raw) + u"\\", lineContinuation);}
    / TokenizerLineTerminatorSequence:lineTerminator
    {
        $$.raw = appendCodePoint(std::move($$.raw), lineTerminator);
        $$.cooked = appendCodePoint(std::move($$.cooked), lineTerminator);
    }
    / !TokenizerLineTerminatorSequence
    [^`\\$]:ch
    {
        $$.raw = appendCodePoint(std::move($$.raw), ch);
        $$.cooked = appendCodePoint(std::move($$.cooked), ch);
    }
    ;

IdentifierName:String =
    TokenizerTokenSeperator<true>
    TokenizerIdentifierName:value
    {$$ = value;}
    ;

TokenNoSubstitutionTemplate:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerNoSubstitutionTemplate:value
    {$$ = std::move(value);}
    ;

TokenTemplateHead:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerTemplateHead:value
    {$$ = std::move(value);}
    ;

TokenTemplateMiddle:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerTemplateMiddle:value
    {$$ = std::move(value);}
    ;

TokenTemplateTail:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerTemplateTail:value
    {$$ = std::move(value);}
    ;

TokenAwait = TokenizerTokenSeperator<true> TokenizerAwait;
TokenBreak = TokenizerTokenSeperator<true> TokenizerBreak;
TokenCase = TokenizerTokenSeperator<true> TokenizerCase;
TokenCatch = TokenizerTokenSeperator<true> TokenizerCatch;
TokenClass = TokenizerTokenSeperator<true> TokenizerClass;
TokenConst = TokenizerTokenSeperator<true> TokenizerConst;
TokenContinue = TokenizerTokenSeperator<true> TokenizerContinue;
TokenDebugger = TokenizerTokenSeperator<true> TokenizerDebugger;
TokenDefault = TokenizerTokenSeperator<true> TokenizerDefault;
TokenDelete = TokenizerTokenSeperator<true> TokenizerDelete;
TokenDo = TokenizerTokenSeperator<true> TokenizerDo;
TokenElse = TokenizerTokenSeperator<true> TokenizerElse;
TokenEnum = TokenizerTokenSeperator<true> TokenizerEnum;
TokenExport = TokenizerTokenSeperator<true> TokenizerExport;
TokenExtends = TokenizerTokenSeperator<true> TokenizerExtends;
TokenFalse = TokenizerTokenSeperator<true> TokenizerFalse;
TokenFinally = TokenizerTokenSeperator<true> TokenizerFinally;
TokenFor = TokenizerTokenSeperator<true> TokenizerFor;
TokenFunction = TokenizerTokenSeperator<true> TokenizerFunction;
TokenIf = TokenizerTokenSeperator<true> TokenizerIf;
TokenImplements = TokenizerTokenSeperator<true> TokenizerImplements;
TokenImport = TokenizerTokenSeperator<true> TokenizerImport;
TokenIn = TokenizerTokenSeperator<true> TokenizerIn;
TokenInstanceOf = TokenizerTokenSeperator<true> TokenizerInstanceOf;
TokenInterface = TokenizerTokenSeperator<true> TokenizerInterface;
TokenNew = TokenizerTokenSeperator<true> TokenizerNew;
TokenNull = TokenizerTokenSeperator<true> TokenizerNull;
TokenPackage = TokenizerTokenSeperator<true> TokenizerPackage;
TokenPrivate = TokenizerTokenSeperator<true> TokenizerPrivate;
TokenProtected = TokenizerTokenSeperator<true> TokenizerProtected;
TokenPublic = TokenizerTokenSeperator<true> TokenizerPublic;
TokenReturn = TokenizerTokenSeperator<true> TokenizerReturn;
TokenSuper = TokenizerTokenSeperator<true> TokenizerSuper;
TokenSwitch = TokenizerTokenSeperator<true> TokenizerSwitch;
TokenThis = TokenizerTokenSeperator<true> TokenizerThis;
TokenThrow = TokenizerTokenSeperator<true> TokenizerThrow;
TokenTrue = TokenizerTokenSeperator<true> TokenizerTrue;
TokenTry = TokenizerTokenSeperator<true> TokenizerTry;
TokenTypeOf = TokenizerTokenSeperator<true> TokenizerTypeOf;
TokenVar = TokenizerTokenSeperator<true> TokenizerVar;
TokenVoid = TokenizerTokenSeperator<true> TokenizerVoid;
TokenWhile = TokenizerTokenSeperator<true> TokenizerWhile;
TokenWith = TokenizerTokenSeperator<true> TokenizerWith;
TokenYield = TokenizerTokenSeperator<true> TokenizerYield;

TokenLBrace = TokenizerTokenSeperator<true> TokenizerLBrace;
TokenRBrace = TokenizerTokenSeperator<true> TokenizerRBrace;
TokenLParen = TokenizerTokenSeperator<true> TokenizerLParen;
TokenRParen = TokenizerTokenSeperator<true> TokenizerRParen;
TokenLBracket = TokenizerTokenSeperator<true> TokenizerLBracket;
TokenRBracket = TokenizerTokenSeperator<true> TokenizerRBracket;
TokenPeriod = TokenizerTokenSeperator<true> TokenizerPeriod;
TokenEllipsis = TokenizerTokenSeperator<true> TokenizerEllipsis;
TokenSemicolon = TokenizerTokenSeperator<true> TokenizerSemicolon;
TokenComma = TokenizerTokenSeperator<true> TokenizerComma;
TokenLAngle = TokenizerTokenSeperator<true> TokenizerLAngle;
TokenRAngle = TokenizerTokenSeperator<true> TokenizerRAngle;
TokenLAngleEqual = TokenizerTokenSeperator<true> TokenizerLAngleEqual;
TokenRAngleEqual = TokenizerTokenSeperator<true> TokenizerRAngleEqual;
TokenEqualEqual = TokenizerTokenSeperator<true> TokenizerEqualEqual;
TokenEMarkEqual = TokenizerTokenSeperator<true> TokenizerEMarkEqual;
TokenEqualEqualEqual = TokenizerTokenSeperator<true> TokenizerEqualEqualEqual;
TokenEMarkEqualEqual = TokenizerTokenSeperator<true> TokenizerEMarkEqualEqual;
TokenPlus = TokenizerTokenSeperator<true> TokenizerPlus;
TokenMinus = TokenizerTokenSeperator<true> TokenizerMinus;
TokenStar = TokenizerTokenSeperator<true> TokenizerStar;
TokenStarStar = TokenizerTokenSeperator<true> TokenizerStarStar;
TokenPercent = TokenizerTokenSeperator<true> TokenizerPercent;
TokenPlusPlus = TokenizerTokenSeperator<true> TokenizerPlusPlus;
TokenMinusMinus = TokenizerTokenSeperator<true> TokenizerMinusMinus;
TokenLAngleLAngle = TokenizerTokenSeperator<true> TokenizerLAngleLAngle;
TokenRAngleRAngle = TokenizerTokenSeperator<true> TokenizerRAngleRAngle;
TokenRAngleRAngleRAngle = TokenizerTokenSeperator<true> TokenizerRAngleRAngleRAngle;
TokenAmp = TokenizerTokenSeperator<true> TokenizerAmp;
TokenPipe = TokenizerTokenSeperator<true> TokenizerPipe;
TokenCaret = TokenizerTokenSeperator<true> TokenizerCaret;
TokenEMark = TokenizerTokenSeperator<true> TokenizerEMark;
TokenTilde = TokenizerTokenSeperator<true> TokenizerTilde;
TokenAmpAmp = TokenizerTokenSeperator<true> TokenizerAmpAmp;
TokenPipePipe = TokenizerTokenSeperator<true> TokenizerPipePipe;
TokenQMark = TokenizerTokenSeperator<true> TokenizerQMark;
TokenColon = TokenizerTokenSeperator<true> TokenizerColon;
TokenEqual = TokenizerTokenSeperator<true> TokenizerEqual;
TokenPlusEqual = TokenizerTokenSeperator<true> TokenizerPlusEqual;
TokenMinusEqual = TokenizerTokenSeperator<true> TokenizerMinusEqual;
TokenStarEqual = TokenizerTokenSeperator<true> TokenizerStarEqual;
TokenPercentEqual = TokenizerTokenSeperator<true> TokenizerPercentEqual;
TokenLAngleLAngleEqual = TokenizerTokenSeperator<true> TokenizerLAngleLAngleEqual;
TokenRAngleRAngleEqual = TokenizerTokenSeperator<true> TokenizerRAngleRAngleEqual;
TokenRAngleRAngleRAngleEqual = TokenizerTokenSeperator<true> TokenizerRAngleRAngleRAngleEqual;
TokenAmpEqual = TokenizerTokenSeperator<true> TokenizerAmpEqual;
TokenPipeEqual = TokenizerTokenSeperator<true> TokenizerPipeEqual;
TokenCaretEqual = TokenizerTokenSeperator<true> TokenizerCaretEqual;
TokenArrow = TokenizerTokenSeperator<true> TokenizerArrow;
TokenFSlash = TokenizerTokenSeperator<true> TokenizerFSlash;
TokenFSlashEqual = TokenizerTokenSeperator<true> TokenizerFSlashEqual;

TokenIdentifier<isModule:bool, isStrict:bool>:String =
    TokenizerTokenSeperator<true>
    !TokenizerReservedWord
    TokenizerIdentifierName:value
    {$$ = value;};

TokenIdentifierOrYield<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:String =
    &{
        if(!canHaveYieldOperator || isStrict)
            $? = "yield not allowed here";
    }
    TokenYield
    {$$ = u"yield";}
    / TokenIdentifier:value
    {$$ = value;}
    ;

TokenNumericLiteral:String =
    TokenizerTokenSeperator<true>
    TokenizerNumericLiteral:value
    {$$ = value;}
    ;

TokenStringLiteral:String =
    TokenizerTokenSeperator<true>
    TokenizerStringLiteral:value
    {$$ = value;}
    ;

TokenRegularExpressionLiteral:BodyAndFlags =
    TokenizerTokenSeperator<true>
    TokenizerRegularExpressionLiteral:value
    {$$ = value;}
    ;

RegularExpressionLiteral:ExpressionPointer =
    TokenRegularExpressionLiteral:regExp
    {$$ = arena.make<ast::ExpressionRegExpLiteral>($_, regExp.body, regExp.flags);}
    ;

IdentifierReference<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenIdentifierOrYield:name
    {$$ = arena.make<ast::ExpressionIdentifierReference>($_, name);}
    ;

FunctionExpression<isModule:bool, isStrict:bool>:ExpressionPointer =
    &{
        $? = "FunctionExpression not implemented";
#warning implement FunctionExpression
    };

GeneratorExpression<isModule:bool, isStrict:bool>:ExpressionPointer =
    &{
        $? = "GeneratorExpression not implemented";
#warning implement GeneratorExpression
    };

ClassExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ClassExpression not implemented";
#warning implement ClassExpression
    };

ParenthesizedExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    "("
    Expression<isModule, isStrict, true, canHaveYieldOperator>:expression
    ")"
    (
        &TokenizerTokenSeperatorWithLineTerminator
        / !TokenArrow
    )
    {$$ = expression;};

PrimaryExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenThis
    {$$ = arena.make<ast::ExpressionThis>($_);}
    / IdentifierReference:identifierReference
    {$$ = identifierReference;}
    / Literal:literal
    {$$ = literal;}
    / ArrayLiteral:arrayLiteral
    {$$ = arrayLiteral;}
    / ObjectLiteral:objectLiteral
    {$$ = objectLiteral;}
    / FunctionExpression:functionExpression
    {$$ = functionExpression;}
    / ClassExpression:classExpression
    {$$ = classExpression;}
    / GeneratorExpression:generatorExpression
    {$$ = generatorExpression;}
    / RegularExpressionLiteral:regularExpressionLiteral
    {$$ = regularExpressionLiteral;}
    / TemplateLiteral:templateLiteral
    {$$ = templateLiteral;}
    / ParenthesizedExpression:parenthesizedExpression
    {$$ = parenthesizedExpression;}
    ;

Literal:ExpressionPointer =
    TokenNull
    {$$ = arena.make<ast::ExpressionNullLiteral>($_);}
    / TokenFalse
    {$$ = arena.make<ast::ExpressionBooleanLiteral>($_, false);}
    / TokenTrue
    {$$ = arena.make<ast::ExpressionBooleanLiteral>($_, true);}
    / TokenNumericLiteral:numericLiteral
    {$$ = arena.make<ast::ExpressionNumericLiteral>($_, value::StringHandle::toNumberValue(numericLiteral));}
    / TokenStringLiteral:stringLiteral
    {$$ = arena.make<ast::ExpressionStringLiteral>($_, stringLiteral);}
    ;

ArrayLiteralElement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArrayLiteralElementPointer =
    &(
        TokenComma
        !TokenRBracket
    )
    {$$ = nullptr;}
    / TokenEllipsis
    AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:spreadExpression
    {$$ = arena.make<ast::SpreadArrayLiteralElement>($_, spreadExpression);}
    / AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:expression
    {$$ = arena.make<ast::ExpressionArrayLiteralElement>($_, expression);}
    ;

ArrayLiteralElementList<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArrayLiteralElementList =
    (
        ArrayLiteralElement:element
        TokenComma
        {$$.push_back(element);}
    )*
    (
        ArrayLiteralElement:lastElement
        {$$.push_back(lastElement);}
    )?
    ;

ArrayLiteral<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenLBracket
    ArrayLiteralElementList:elements
    TokenRBracket
    {$$ = arena.make<ast::ExpressionArrayLiteral>($_, std::move(elements));}
    ;

ObjectLiteral<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ObjectLiteral not implemented";
#warning implement ObjectLiteral
    };

TemplateLiteralRest<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:TemplateRest =
    (
        Expression<isModule, isStrict, true, canHaveYieldOperator>:expression
        TokenTemplateMiddle:middle
        {$$.emplace_back(expression, ast::TemplateString(middle.raw, middle.cooked));}
    )*
    Expression<isModule, isStrict, true, canHaveYieldOperator>:lastExpression
    TokenTemplateTail:tail
    {$$.emplace_back(lastExpression, ast::TemplateString(tail.raw, tail.cooked));}
    ;

TemplateLiteral<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenNoSubstitutionTemplate:noSubstitutionTemplate
    {
        $$ = arena.make<ast::ExpressionTemplateLiteral>($_,
                                                        ast::TemplateString(noSubstitutionTemplate.raw,
                                                                       noSubstitutionTemplate.cooked));
    }
    / TokenTemplateHead:first
    TemplateLiteralRest:rest
    {
        $$ = arena.make<ast::ExpressionTemplateLiteral>($_, ast::TemplateString(first.raw, first.cooked), std::move(rest));
    }
    ;

ArrowFunction<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ArrowFunction not implemented";
#warning implement ArrowFunction
    };

YieldExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool>:ExpressionPointer =
    &{
        $? = "YieldExpression not implemented";
#warning implement YieldExpression
    };

LeftHandSideExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "LeftHandSideExpression not implemented";
#warning implement LeftHandSideExpression
    };

ShiftExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ShiftExpression not implemented";
#warning implement ShiftExpression
    };
    
RelationalExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    ShiftExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLAngle
        ShiftExpression:compareLT
        {$$ = arena.make<ast::ExpressionCompareLT>($_, $$, compareLT);}
        / TokenRAngle
        ShiftExpression:compareGT
        {$$ = arena.make<ast::ExpressionCompareGT>($_, $$, compareGT);}
        / TokenLAngleEqual
        ShiftExpression:compareLE
        {$$ = arena.make<ast::ExpressionCompareLE>($_, $$, compareLE);}
        / TokenRAngleEqual
        ShiftExpression:compareGE
        {$$ = arena.make<ast::ExpressionCompareGE>($_, $$, compareGE);}
        / TokenInstanceOf
        ShiftExpression:instanceOfExpression
        {$$ = arena.make<ast::ExpressionInstanceOf>($_, $$, instanceOfExpression);}
        / &{
            if(!canHaveInOperator)
                $? = "in not allowed here";
        } 
        TokenIn
        ShiftExpression:inExpression
        {$$ = arena.make<ast::ExpressionIn>($_, $$, inExpression);}
    )*
    ;

EqualityExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    RelationalExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenEqualEqual
        RelationalExpression:compareEq
        {$$ = arena.make<ast::ExpressionCompareEq>($_, $$, compareEq);}
        / TokenEMarkEqual
        RelationalExpression:compareNE
        {$$ = arena.make<ast::ExpressionCompareNE>($_, $$, compareNE);}
        / TokenEqualEqualEqual
        RelationalExpression:compareStrictEq
        {$$ = arena.make<ast::ExpressionCompareStrictEq>($_, $$, compareStrictEq);}
        / TokenEMarkEqualEqual
        RelationalExpression:compareStrictNE
        {$$ = arena.make<ast::ExpressionCompareStrictNE>($_, $$, compareStrictNE);}
    )*
    ;

BitwiseANDExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    EqualityExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenAmp
        EqualityExpression:nextExpression
        {$$ = arena.make<ast::ExpressionBitwiseAnd>($_, $$, nextExpression);}
    )*
    ;

BitwiseXORExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    BitwiseANDExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenCaret
        BitwiseANDExpression:nextExpression
        {$$ = arena.make<ast::ExpressionBitwiseXor>($_, $$, nextExpression);}
    )*
    ;

BitwiseORExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    BitwiseXORExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenPipe
        BitwiseXORExpression:nextExpression
        {$$ = arena.make<ast::ExpressionBitwiseOr>($_, $$, nextExpression);}
    )*
    ;

LogicalANDExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    BitwiseORExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenAmpAmp
        BitwiseORExpression:nextExpression
        {$$ = arena.make<ast::ExpressionLogicalAnd>($_, $$, nextExpression);}
    )*
    ;

LogicalORExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    LogicalANDExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenPipePipe
        LogicalANDExpression:nextExpression
        {$$ = arena.make<ast::ExpressionLogicalOr>($_, $$, nextExpression);}
    )*
    ;

ConditionalExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    LogicalORExpression:condition
    {$$ = condition;}
    (
        TokenQMark
        AssignmentExpression:trueExpression
        TokenColon
        AssignmentExpression:falseExpression
        {$$ = arena.make<ast::ExpressionConditional>($_, condition, trueExpression, falseExpression);}
    )?;

AssignmentExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    ArrowFunction:arrowFunction
    {$$ = arrowFunction;}
    / &(
        TokenYield
        &{
            if(!canHaveYieldOperator)
                $? = "yield not allowed here";
        }
    )
    YieldExpression:yieldExpression
    {$$ = yieldExpression;}
    / LeftHandSideExpression:leftHandSideExpression
    (
        TokenEqual
        AssignmentExpression:assignmentExpression
        {$$ = arena.make<ast::AssignmentExpression>($_, leftHandSideExpression, assignmentExpression);}
        / TokenStarEqual
        AssignmentExpression:multiplyAssignmentExpression
        {$$ = arena.make<ast::MultiplyAssignmentExpression>($_, leftHandSideExpression, multiplyAssignmentExpression);}
        / TokenFSlashEqual
        AssignmentExpression:divideAssignmentExpression
        {$$ = arena.make<ast::DivideAssignmentExpression>($_, leftHandSideExpression, divideAssignmentExpression);}
        / TokenPercentEqual
        AssignmentExpression:modulusAssignmentExpression
        {$$ = arena.make<ast::ModulusAssignmentExpression>($_, leftHandSideExpression, modulusAssignmentExpression);}
        / TokenPlusEqual
        AssignmentExpression:addAssignmentExpression
        {$$ = arena.make<ast::AddAssignmentExpression>($_, leftHandSideExpression, addAssignmentExpression);}
        / TokenMinusEqual
        AssignmentExpression:subtractAssignmentExpression
        {$$ = arena.make<ast::SubtractAssignmentExpression>($_, leftHandSideExpression, subtractAssignmentExpression);}
        / TokenLAngleLAngleEqual
        AssignmentExpression:lShiftAssignmentExpression
        {$$ = arena.make<ast::LShiftAssignmentExpression>($_, leftHandSideExpression, lShiftAssignmentExpression);}
        / TokenRAngleRAngleEqual
        AssignmentExpression:arShiftAssignmentExpression
        {$$ = arena.make<ast::ARShiftAssignmentExpression>($_, leftHandSideExpression, arShiftAssignmentExpression);}
        / TokenRAngleRAngleRAngleEqual
        AssignmentExpression:urShiftAssignmentExpression
        {$$ = arena.make<ast::URShiftAssignmentExpression>($_, leftHandSideExpression, urShiftAssignmentExpression);}
        / TokenAmpEqual
        AssignmentExpression:andAssignmentExpression
        {$$ = arena.make<ast::AndAssignmentExpression>($_, leftHandSideExpression, andAssignmentExpression);}
        / TokenCaretEqual
        AssignmentExpression:xorAssignmentExpression
        {$$ = arena.make<ast::XorAssignmentExpression>($_, leftHandSideExpression, xorAssignmentExpression);}
        / TokenPipeEqual
        AssignmentExpression:orAssignmentExpression
        {$$ = arena.make<ast::OrAssignmentExpression>($_, leftHandSideExpression, orAssignmentExpression);}
    )
    / ConditionalExpression:conditionalExpression
    {$$ = conditionalExpression;};

Expression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    AssignmentExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenComma
        AssignmentExpression:nextExpression
        {$$ = arena.make<ast::ExpressionCommaOperator>($_, $$, nextExpression);}
    )*
    !TokenComma
    ;

