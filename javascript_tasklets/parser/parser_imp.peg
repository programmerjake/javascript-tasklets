code license {
/*
 * Copyright (C) 2012-2016 Jacob R. Lifshay
 * This file is part of Voxels.
 *
 * Voxels is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Voxels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Voxels; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 */

// to regenerate parser_imp.h and parser_imp.cpp, use https://github.com/programmerjake/peg_parser_generator
// command: peg_parser_generator javascript_tasklets/parser/parser_imp.peg
}

namespace javascript_tasklets::parser;

code header {
#include "../string.h"
#include <memory>
#include <vector>
#include "ast/node.h"
#include "ast/expression.h"
#include "ast/statement.h"
#include "ast/declaration.h"
#include "ast/literal.h"
#include "ast/arena.h"
#include "ast/argument.h"
#include "ast/binding.h"

namespace javascript_tasklets
{
namespace parser
{
struct RawAndCookedString final
{
    String raw;
    String cooked;
    RawAndCookedString() : raw(), cooked()
    {
    }
    RawAndCookedString(String raw) : raw(raw), cooked(std::move(raw))
    {
    }
    RawAndCookedString(String raw, String cooked) : raw(std::move(raw)), cooked(std::move(cooked))
    {
    }
};

struct RawStringAndChar final
{
    String raw;
    char32_t ch;
    RawStringAndChar() : raw(), ch()
    {
    }
    RawStringAndChar(String raw, char32_t ch) : raw(std::move(raw)), ch(ch)
    {
    }
};

struct BodyAndFlags final
{
    String body;
    String flags;
    BodyAndFlags() : body(), flags()
    {
    }
    BodyAndFlags(String body, String flags) : body(std::move(body)), flags(std::move(flags))
    {
    }
};

struct DirectivePrologue final
{
    bool useStrict = false;
};

typedef ast::Node *NodePointer;
typedef ast::Expression *ExpressionPointer;
typedef ast::ArrayLiteralElement *ArrayLiteralElementPointer;
typedef std::vector<ast::ArrayLiteralElement *> ArrayLiteralElementList;
typedef ast::Argument *ArgumentPointer;
typedef ast::ExpressionTemplateLiteral *ExpressionTemplateLiteralPointer;
typedef ast::Statement *StatementPointer;
typedef ast::Binding *BindingPointer;
typedef ast::PropertyName *PropertyNamePointer;
}
}
}

code class {
public:
    ast::Arena arena = ast::Arena();
}

code source {
#include "../character_properties.h"
#include "ast/expressions.h"
#include "ast/statements.h"
#include "ast/declarations.h"
#include "../value.h"
}

typedef unsigned unsigned;
typedef bool bool;
typedef String String;
typedef RawAndCookedString RawAndCookedString;
typedef RawStringAndChar RawStringAndChar;
typedef BodyAndFlags BodyAndFlags;
typedef ExpressionPointer ExpressionPointer;
typedef NodePointer NodePointer;
typedef ArrayLiteralElementPointer ArrayLiteralElementPointer;
typedef ArrayLiteralElementList ArrayLiteralElementList;
typedef ast::TemplateRest TemplateRest;
typedef ast::ArgumentList ArgumentList;
typedef ArgumentPointer ArgumentPointer;
typedef ExpressionTemplateLiteralPointer ExpressionTemplateLiteralPointer;
typedef std::size_t Location;
typedef StatementPointer StatementPointer;
typedef ast::StatementList StatementList;
typedef DirectivePrologue DirectivePrologue;
typedef BindingPointer BindingPointer;
typedef PropertyNamePointer PropertyNamePointer;
typedef ast::BindingList BindingList;

TokenizerHexDigitValue:unsigned = 
    [^]:ch
    &{
        auto digitValue = character_properties::javascriptDigitValue(ch);
        if(digitValue >= 0 && digitValue < 0x10)
            $$ = digitValue;
        else
            $? = "missing hex digit";
    };

TokenizerLineTerminatorSequence:char = "\r\n" {$$ = U'\n';}
                                     / "\r" {$$ = U'\n';}
                                     / [^]:char1
                                     &{
                                         $$ = char1;
                                         if(!character_properties::javascriptLineTerminator($$))
                                             $? = "expected a line terminator";
                                     };

TokenizerComment<lineTerminatorAllowed:bool> =
    TokenizerMultiLineComment
    / TokenizerSingleLineComment;

TokenizerMultiLineComment<lineTerminatorAllowed:bool>:bool =
    "/*"
    {$$ = false;}
    (
        !"*/"
        (
            TokenizerLineTerminatorSequence
            &{
                if(!lineTerminatorAllowed)
                    $? = "line terminator not allowed here";
                $$ = true;
            }
            / !TokenizerLineTerminatorSequence
            [^]
        )
    )*
    "*/";

TokenizerSingleLineComment = "//" (!TokenizerLineTerminatorSequence [^])*;

TokenizerTokenSeperator<lineTerminatorAllowed:bool> = 
    (
        TokenizerMultiLineComment
        / TokenizerSingleLineComment
        / TokenizerLineTerminatorSequence
        &{
            if(!lineTerminatorAllowed)
                $? = "line terminator not allowed here";
        }
        / !TokenizerLineTerminatorSequence
        [^]:ch
        &{
            if(!character_properties::javascriptWhiteSpace(ch))
                $? = "not a whitespace character";
        }
    )*;

TokenizerTokenSeperatorWithLineTerminator = 
    TokenizerTokenSeperator<false>
    (
        TokenizerMultiLineComment<true>:hasLineTerminator
        &{
            if(!hasLineTerminator)
                $? = "missing line terminator";
        }
        / TokenizerLineTerminatorSequence
    );
        

TokenizerUnicodeEscapeSequence:RawStringAndChar = "u" {$$ = RawStringAndChar(u"u", 0);} (
    "{"
    {$$.raw += u"{";}
    (
        [^]:digit
        &{
            auto digitValue = character_properties::javascriptDigitValue(digit);
            if(digitValue < 0 || digitValue >= 0x10)
                $? = "missing hex digit";
            else
            {
                $$.ch = $$.ch * 0x10 + digitValue;
                $$.raw = appendCodePoint(std::move($$.raw), digit);
            }
            if($$.ch > 0x10FFFF)
                $? = "unicode escape value is too big";
        }
    )+
    "}"
    {$$.raw += u"}";}
    / [^]:digit1
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit1);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit1);
          }
      }
      [^]:digit2
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit2);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit2);
          }
      }
      [^]:digit3
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit3);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit3);
          }
      }
      [^]:digit4
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit4);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit4);
          }
      }
    );

TokenizerUnicodeEscapeOrChar:char = "\\" TokenizerUnicodeEscapeSequence:escape {$$ = escape.ch;}
                                  / [^]:ch {$$ = ch;};

TokenizerEscapelessIdentifierStart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdStart(ch))
            $? = "expected identifier start";
        else
            $$ = ch;
    };

TokenizerEscapelessIdentifierPart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdContinue(ch))
            $? = "expected identifier part";
        else
            $$ = ch;
    };

TokenizerIdentifierName:String =
    TokenizerUnicodeEscapeOrChar:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = appendCodePoint(u"", startChar);
    }
    (
        TokenizerUnicodeEscapeOrChar:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = appendCodePoint(std::move($$), continueChar);
        }
    )*
    !"\\";

TokenizerEscapelessIdentifierName:String =
    [^]:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = appendCodePoint(u"", startChar);
    }
    (
        [^]:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = appendCodePoint(std::move($$), continueChar);
        }
    )*
    !"\\";

TokenizerReservedWord<isModule:bool, isStrict:bool> = TokenizerKeyword / TokenizerFutureReservedWord / TokenizerNullLiteral / TokenizerBooleanLiteral;

TokenizerAwait = "await" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerBreak = "break" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCase = "case" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCatch = "catch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerClass = "class" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerConst = "const" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerContinue = "continue" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDebugger = "debugger" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDefault = "default" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDelete = "delete" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDo = "do" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerElse = "else" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerEnum = "enum" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExport = "export" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExtends = "extends" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFalse = "false" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFinally = "finally" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFor = "for" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFunction = "function" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIf = "if" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImplements = "implements" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImport = "import" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIn = "in" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInstanceOf = "instanceof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInterface = "interface" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerLet = "let" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNew = "new" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNull = "null" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPackage = "package" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPrivate = "private" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerProtected = "protected" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPublic = "public" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerReturn = "return" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSuper = "super" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSwitch = "switch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTarget = "target" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThis = "this" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThrow = "throw" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTrue = "true" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTry = "try" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTypeOf = "typeof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVar = "var" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVoid = "void" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWhile = "while" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWith = "with" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerYield = "yield" !"\\" !TokenizerEscapelessIdentifierPart;

TokenizerKeyword = TokenizerBreak
                 / TokenizerCase
                 / TokenizerCatch
                 / TokenizerClass
                 / TokenizerConst
                 / TokenizerContinue
                 / TokenizerDebugger
                 / TokenizerDefault
                 / TokenizerDelete
                 / TokenizerDo
                 / TokenizerElse
                 / TokenizerExport
                 / TokenizerExtends
                 / TokenizerFinally
                 / TokenizerFor
                 / TokenizerFunction
                 / TokenizerIf
                 / TokenizerImport
                 / TokenizerIn
                 / TokenizerInstanceOf
                 / TokenizerNew
                 / TokenizerReturn
                 / TokenizerSuper
                 / TokenizerSwitch
                 / TokenizerThis
                 / TokenizerThrow
                 / TokenizerTry
                 / TokenizerTypeOf
                 / TokenizerVar
                 / TokenizerVoid
                 / TokenizerWhile
                 / TokenizerWith
                 / TokenizerYield;

TokenizerFutureReservedWord<isModule:bool, isStrict:bool> =
    TokenizerAwait &{if(isModule) $? = "not in a module";}
    / TokenizerEnum
    / &{if(!isStrict) $? = "not strict";}
    (
        TokenizerImplements
        / TokenizerInterface
        / TokenizerPackage
        / TokenizerPrivate
        / TokenizerProtected
        / TokenizerPublic
    );

TokenizerNullLiteral = TokenizerNull;

TokenizerBooleanLiteral:bool = TokenizerTrue {$$ = true;} / TokenizerFalse {$$ = false;};

TokenizerLBrace = "{";
TokenizerRBrace = "}";
TokenizerLParen = "(";
TokenizerRParen = ")";
TokenizerLBracket = "[";
TokenizerRBracket = "]";
TokenizerPeriod = !"..." "." ![0-9];
TokenizerEllipsis = "...";
TokenizerSemicolon = ";";
TokenizerComma = ",";
TokenizerLAngle = "<" ![<=];
TokenizerRAngle = ">" ![>=];
TokenizerLAngleEqual = "<=";
TokenizerRAngleEqual = ">=";
TokenizerEqualEqual = "==" !"=";
TokenizerEMarkEqual = "!=" !"=";
TokenizerEqualEqualEqual = "===";
TokenizerEMarkEqualEqual = "!==";
TokenizerPlus = "+" ![+=];
TokenizerMinus = "-" ![\-=];
TokenizerStar = "*" ![*=];
TokenizerStarStar = "**";
TokenizerPercent = "%" !"=";
TokenizerPlusPlus = "++";
TokenizerMinusMinus = "--";
TokenizerLAngleLAngle = "<<" !"=";
TokenizerRAngleRAngle = ">>" ![>=];
TokenizerRAngleRAngleRAngle = ">>>" !"=";
TokenizerAmp = "&" ![&=];
TokenizerPipe = "|" ![|=];
TokenizerCaret = "^" !"=";
TokenizerEMark = "!" !"=";
TokenizerTilde = "~";
TokenizerAmpAmp = "&&";
TokenizerPipePipe = "||";
TokenizerQMark = "?";
TokenizerColon = ":";
TokenizerEqual = "=" ![=>];
TokenizerPlusEqual = "+=";
TokenizerMinusEqual = "-=";
TokenizerStarEqual = "*=";
TokenizerPercentEqual = "%=";
TokenizerLAngleLAngleEqual = "<<=";
TokenizerRAngleRAngleEqual = ">>=";
TokenizerRAngleRAngleRAngleEqual = ">>>=";
TokenizerAmpEqual = "&=";
TokenizerPipeEqual = "|=";
TokenizerCaretEqual = "^=";
TokenizerArrow = "=>";
TokenizerFSlash = "/" ![=/*];
TokenizerFSlashEqual = "/=";

TokenizerPunctuator = TokenizerLBrace
                    / TokenizerLParen
                    / TokenizerRParen
                    / TokenizerLBracket
                    / TokenizerRBracket
                    / TokenizerPeriod
                    / TokenizerEllipsis
                    / TokenizerSemicolon
                    / TokenizerComma
                    / TokenizerLAngle
                    / TokenizerRAngle
                    / TokenizerLAngleEqual
                    / TokenizerRAngleEqual
                    / TokenizerEqualEqual
                    / TokenizerEMarkEqual
                    / TokenizerEqualEqualEqual
                    / TokenizerEMarkEqualEqual
                    / TokenizerPlus
                    / TokenizerMinus
                    / TokenizerStar
                    / TokenizerStarStar
                    / TokenizerPercent
                    / TokenizerPlusPlus
                    / TokenizerMinusMinus
                    / TokenizerLAngleLAngle
                    / TokenizerRAngleRAngle
                    / TokenizerRAngleRAngleRAngle
                    / TokenizerAmp
                    / TokenizerPipe
                    / TokenizerCaret
                    / TokenizerEMark
                    / TokenizerTilde
                    / TokenizerAmpAmp
                    / TokenizerPipePipe
                    / TokenizerQMark
                    / TokenizerColon
                    / TokenizerEqual
                    / TokenizerPlusEqual
                    / TokenizerMinusEqual
                    / TokenizerStarEqual
                    / TokenizerPercentEqual
                    / TokenizerLAngleLAngleEqual
                    / TokenizerRAngleRAngleEqual
                    / TokenizerRAngleRAngleRAngleEqual
                    / TokenizerAmpEqual
                    / TokenizerPipeEqual
                    / TokenizerCaretEqual
                    / TokenizerArrow;

TokenizerDivPunctuator = TokenizerFSlash / TokenizerFSlashEqual;

TokenizerRightBracePunctuator = TokenizerRBrace;

TokenizerNumericLiteral:String = TokenizerDecimalLiteral:value0 {$$ = value0;}
                               / TokenizerBinaryIntegerLiteral:value1 {$$ = value1;}
                               / TokenizerOctalIntegerLiteral:value2 {$$ = value2;}
                               / TokenizerHexIntegerLiteral:value3 {$$ = value3;};

TokenizerDecimalLiteral:String = TokenizerDecimalIntegerLiteral:value0 {$$ = value0;}
                                 "." {$$ += u'.';}
                                 (
                                     TokenizerDecimalDigits:value1 {$$ += value1;}
                                 )?
                                 (
                                     TokenizerExponentPart:value2 {$$ += value2;}
                                 )?
                               / "." {$$ = u'.';}
                                 TokenizerDecimalDigits:value3 {$$ += value3;}
                                 (
                                     TokenizerExponentPart:value4 {$$ += value4;}
                                 )?
                               / TokenizerDecimalIntegerLiteral:value5 {$$ = value5;}
                                 (
                                     TokenizerExponentPart:value6 {$$ += value6;}
                                 )?
                               ;

TokenizerDecimalIntegerLiteral:String =
    "0" {$$ = u"0";} ![0-9]
    / [1-9]:nonZeroDigit
    {$$ = appendCodePoint(u"", nonZeroDigit);}
    (TokenizerDecimalDigits:digits {$$ += digits;})?;

TokenizerDecimalDigits:String =
    {$$ = u"";}
    (
        [0-9]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerExponentPart:String =
    [eE]:exponentIndicator
    {$$ = appendCodePoint(u"", exponentIndicator);}
    TokenizerSignedInteger:signedInteger
    {$$ += signedInteger;}
    ;

TokenizerSignedInteger:String =
    {$$ = u"";}
    (
        [+\-]:sign
        {$$ = appendCodePoint(u"", sign);}
    )?
    TokenizerDecimalDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [bB]:binaryIndicator
    {$$ = appendCodePoint(std::move($$), binaryIndicator);}
    TokenizerBinaryDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryDigits:String =
    {$$ = u"";}
    (
        [01]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerOctalIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [oO]:octalIndicator
    {$$ = appendCodePoint(std::move($$), octalIndicator);}
    TokenizerOctalDigits:digits
    {$$ += digits;}
    ;

TokenizerOctalDigits:String =
    {$$ = u"";}
    (
        [0-7]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerHexIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [xX]:hexIndicator
    {$$ = appendCodePoint(std::move($$), hexIndicator);}
    TokenizerHexDigits:digits
    {$$ += digits;}
    ;

TokenizerHexDigits:String =
    {$$ = u"";}
    (
        [0-9a-fA-F]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerStringLiteral:String =
    "\'"
    {$$ = u"";}
    (
        TokenizerSingleStringCharacters:characters1
        {$$ = characters1;}
    )?
    "\'"
    / "\""
    {$$ = u"";}
    (
        TokenizerDoubleStringCharacters:characters2
        {$$ = characters2;}
    )?
    "\"";

TokenizerSingleStringCharacters:String =
    TokenizerSingleStringCharacter:first
    {$$ = first;}
    (
        TokenizerSingleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerDoubleStringCharacters:String =
    TokenizerDoubleStringCharacter:first
    {$$ = first;}
    (
        TokenizerDoubleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerSingleStringCharacter:String =
    !"\'"
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerDoubleStringCharacter:String =
    !"\""
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerLineContinuation:String = "\\" TokenizerLineTerminatorSequence:lineTerminator {$$ = appendCodePoint(u"\\", lineTerminator);};

TokenizerEscapeSequence:RawAndCookedString =
    "0"
    ![0-9]
    {$$ = RawAndCookedString(u"0", String(1, u'\0'));}
    / TokenizerCharacterEscapeSequence:characterEscape
    {$$ = characterEscape;}
    / TokenizerUnicodeEscapeSequence:unicodeEscape
    {$$ = RawAndCookedString(unicodeEscape.raw, appendCodePoint(u"", unicodeEscape.ch));}
    / TokenizerHexEscapeSequence:hexEscape
    {$$ = RawAndCookedString(hexEscape.raw, appendCodePoint(u"", hexEscape.ch));}
    ;

TokenizerHexEscapeSequence:RawStringAndChar = 
    "x"
    {$$ = RawStringAndChar(u"x", 0);}
    [^]:digit1
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit1);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit1);
        }
    }
    [^]:digit2
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit2);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit2);
        }
    }
    ;

TokenizerCharacterEscapeSequence:RawAndCookedString =
    TokenizerSingleEscapeCharacter:singleEscapeCharacter
    {$$ = singleEscapeCharacter;}
    / TokenizerNonEscapeCharacter:nonEscapeCharacter
    {$$ = RawAndCookedString(appendCodePoint(u"", nonEscapeCharacter));}
    ;

TokenizerSingleEscapeCharacter:RawAndCookedString =
    ['"\\]:char1
    {$$ = RawAndCookedString(appendCodePoint(u"", char1));}
    / "b"
    {$$ = RawAndCookedString(u"b", u"\b");}
    / "f"
    {$$ = RawAndCookedString(u"f", u"\f");}
    / "n"
    {$$ = RawAndCookedString(u"n", u"\n");}
    / "r"
    {$$ = RawAndCookedString(u"r", u"\r");}
    / "t"
    {$$ = RawAndCookedString(u"t", u"\t");}
    / "v"
    {$$ = RawAndCookedString(u"v", u"\v");}
    ;

TokenizerNonEscapeCharacter:char =
    !TokenizerLineTerminatorSequence
    ![0-9xu]
    !TokenizerSingleEscapeCharacter
    [^]:ch
    {$$ = ch;}
    ;

TokenizerRegularExpressionLiteral:BodyAndFlags =
    "/"
    TokenizerRegularExpressionBody:body
    "/"
    TokenizerRegularExpressionFlags:flags
    {$$ = BodyAndFlags(body, flags);};

TokenizerRegularExpressionBody:String =
    !"*"
    {$$ = u"";}
    (
        TokenizerRegularExpressionChar:value
        {$$ += value;}
    )+;

TokenizerRegularExpressionChar:String =
    ![\\/[]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    / TokenizerRegularExpressionClass:classValue
    {$$ = classValue;}
    ;

TokenizerRegularExpressionBackslashSequence:String =
    "\\"
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"\\", nonTerminator);}
    ;

TokenizerRegularExpressionClass:String =
    "["
    {$$ = u"[";}
    (
        TokenizerRegularExpressionClassChar:classChar
        {$$ += classChar;}
    )*
    "]"
    {$$ += u"]";}
    ;

TokenizerRegularExpressionClassChar:String =
    ![\\\]]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    ;

TokenizerRegularExpressionFlags:String =
    {$$ = u"";}
    (
        TokenizerEscapelessIdentifierPart:ch
        {$$ = appendCodePoint(std::move($$), ch);}
        / "\\"
        TokenizerUnicodeEscapeSequence:unicodeEscape
        {$$ += u"\\" + unicodeEscape.raw;}
    )*
    !"\\"
    ;

TokenizerNoSubstitutionTemplate:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateHead:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateMiddle:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateTail:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateCharacter:RawAndCookedString =
    "$"
    !"{"
    {$$ = RawAndCookedString(u"$");}
    / "\\"
    TokenizerEscapeSequence:escapeSequence
    {$$.raw += u"\\" + escapeSequence.raw; $$.cooked += escapeSequence.cooked;}
    / "\\"
    TokenizerLineTerminatorSequence:lineContinuation
    {$$.raw = appendCodePoint(std::move($$.raw) + u"\\", lineContinuation);}
    / TokenizerLineTerminatorSequence:lineTerminator
    {
        $$.raw = appendCodePoint(std::move($$.raw), lineTerminator);
        $$.cooked = appendCodePoint(std::move($$.cooked), lineTerminator);
    }
    / !TokenizerLineTerminatorSequence
    [^`\\$]:ch
    {
        $$.raw = appendCodePoint(std::move($$.raw), ch);
        $$.cooked = appendCodePoint(std::move($$.cooked), ch);
    }
    ;

IdentifierName:String =
    TokenizerTokenSeperator<true>
    TokenizerIdentifierName:value
    {$$ = value;}
    ;

TokenNoSubstitutionTemplate:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerNoSubstitutionTemplate:value
    {$$ = std::move(value);}
    ;

TokenTemplateHead:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerTemplateHead:value
    {$$ = std::move(value);}
    ;

TokenTemplateMiddle:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerTemplateMiddle:value
    {$$ = std::move(value);}
    ;

TokenTemplateTail:RawAndCookedString =
    TokenizerTokenSeperator<true>
    TokenizerTemplateTail:value
    {$$ = std::move(value);}
    ;

TokenAwait = TokenizerTokenSeperator<true> TokenizerAwait;
TokenBreak = TokenizerTokenSeperator<true> TokenizerBreak;
TokenCase = TokenizerTokenSeperator<true> TokenizerCase;
TokenCatch = TokenizerTokenSeperator<true> TokenizerCatch;
TokenClass = TokenizerTokenSeperator<true> TokenizerClass;
TokenConst = TokenizerTokenSeperator<true> TokenizerConst;
TokenContinue = TokenizerTokenSeperator<true> TokenizerContinue;
TokenDebugger = TokenizerTokenSeperator<true> TokenizerDebugger;
TokenDefault = TokenizerTokenSeperator<true> TokenizerDefault;
TokenDelete = TokenizerTokenSeperator<true> TokenizerDelete;
TokenDo = TokenizerTokenSeperator<true> TokenizerDo;
TokenElse = TokenizerTokenSeperator<true> TokenizerElse;
TokenEnum = TokenizerTokenSeperator<true> TokenizerEnum;
TokenExport = TokenizerTokenSeperator<true> TokenizerExport;
TokenExtends = TokenizerTokenSeperator<true> TokenizerExtends;
TokenFalse = TokenizerTokenSeperator<true> TokenizerFalse;
TokenFinally = TokenizerTokenSeperator<true> TokenizerFinally;
TokenFor = TokenizerTokenSeperator<true> TokenizerFor;
TokenFunction = TokenizerTokenSeperator<true> TokenizerFunction;
TokenIf = TokenizerTokenSeperator<true> TokenizerIf;
TokenImplements = TokenizerTokenSeperator<true> TokenizerImplements;
TokenImport = TokenizerTokenSeperator<true> TokenizerImport;
TokenIn = TokenizerTokenSeperator<true> TokenizerIn;
TokenInstanceOf = TokenizerTokenSeperator<true> TokenizerInstanceOf;
TokenInterface = TokenizerTokenSeperator<true> TokenizerInterface;
TokenLet = TokenizerTokenSeperator<true> TokenizerLet;
TokenNew = TokenizerTokenSeperator<true> TokenizerNew;
TokenNull = TokenizerTokenSeperator<true> TokenizerNull;
TokenPackage = TokenizerTokenSeperator<true> TokenizerPackage;
TokenPrivate = TokenizerTokenSeperator<true> TokenizerPrivate;
TokenProtected = TokenizerTokenSeperator<true> TokenizerProtected;
TokenPublic = TokenizerTokenSeperator<true> TokenizerPublic;
TokenReturn = TokenizerTokenSeperator<true> TokenizerReturn;
TokenSuper = TokenizerTokenSeperator<true> TokenizerSuper;
TokenSwitch = TokenizerTokenSeperator<true> TokenizerSwitch;
TokenTarget = TokenizerTokenSeperator<true> TokenizerTarget;
TokenThis = TokenizerTokenSeperator<true> TokenizerThis;
TokenThrow = TokenizerTokenSeperator<true> TokenizerThrow;
TokenTrue = TokenizerTokenSeperator<true> TokenizerTrue;
TokenTry = TokenizerTokenSeperator<true> TokenizerTry;
TokenTypeOf = TokenizerTokenSeperator<true> TokenizerTypeOf;
TokenVar = TokenizerTokenSeperator<true> TokenizerVar;
TokenVoid = TokenizerTokenSeperator<true> TokenizerVoid;
TokenWhile = TokenizerTokenSeperator<true> TokenizerWhile;
TokenWith = TokenizerTokenSeperator<true> TokenizerWith;
TokenYield = TokenizerTokenSeperator<true> TokenizerYield;

TokenLBrace = TokenizerTokenSeperator<true> TokenizerLBrace;
TokenRBrace = TokenizerTokenSeperator<true> TokenizerRBrace;
TokenLParen = TokenizerTokenSeperator<true> TokenizerLParen;
TokenRParen = TokenizerTokenSeperator<true> TokenizerRParen;
TokenLBracket = TokenizerTokenSeperator<true> TokenizerLBracket;
TokenRBracket = TokenizerTokenSeperator<true> TokenizerRBracket;
TokenPeriod = TokenizerTokenSeperator<true> TokenizerPeriod;
TokenEllipsis = TokenizerTokenSeperator<true> TokenizerEllipsis;
TokenComma = TokenizerTokenSeperator<true> TokenizerComma;
TokenLAngle = TokenizerTokenSeperator<true> TokenizerLAngle;
TokenRAngle = TokenizerTokenSeperator<true> TokenizerRAngle;
TokenLAngleEqual = TokenizerTokenSeperator<true> TokenizerLAngleEqual;
TokenRAngleEqual = TokenizerTokenSeperator<true> TokenizerRAngleEqual;
TokenEqualEqual = TokenizerTokenSeperator<true> TokenizerEqualEqual;
TokenEMarkEqual = TokenizerTokenSeperator<true> TokenizerEMarkEqual;
TokenEqualEqualEqual = TokenizerTokenSeperator<true> TokenizerEqualEqualEqual;
TokenEMarkEqualEqual = TokenizerTokenSeperator<true> TokenizerEMarkEqualEqual;
TokenPlus = TokenizerTokenSeperator<true> TokenizerPlus;
TokenMinus = TokenizerTokenSeperator<true> TokenizerMinus;
TokenStar = TokenizerTokenSeperator<true> TokenizerStar;
TokenStarStar = TokenizerTokenSeperator<true> TokenizerStarStar;
TokenPercent = TokenizerTokenSeperator<true> TokenizerPercent;
TokenPlusPlus = TokenizerTokenSeperator<true> TokenizerPlusPlus;
TokenMinusMinus = TokenizerTokenSeperator<true> TokenizerMinusMinus;
TokenLAngleLAngle = TokenizerTokenSeperator<true> TokenizerLAngleLAngle;
TokenRAngleRAngle = TokenizerTokenSeperator<true> TokenizerRAngleRAngle;
TokenRAngleRAngleRAngle = TokenizerTokenSeperator<true> TokenizerRAngleRAngleRAngle;
TokenAmp = TokenizerTokenSeperator<true> TokenizerAmp;
TokenPipe = TokenizerTokenSeperator<true> TokenizerPipe;
TokenCaret = TokenizerTokenSeperator<true> TokenizerCaret;
TokenEMark = TokenizerTokenSeperator<true> TokenizerEMark;
TokenTilde = TokenizerTokenSeperator<true> TokenizerTilde;
TokenAmpAmp = TokenizerTokenSeperator<true> TokenizerAmpAmp;
TokenPipePipe = TokenizerTokenSeperator<true> TokenizerPipePipe;
TokenQMark = TokenizerTokenSeperator<true> TokenizerQMark;
TokenColon = TokenizerTokenSeperator<true> TokenizerColon;
TokenEqual = TokenizerTokenSeperator<true> TokenizerEqual;
TokenPlusEqual = TokenizerTokenSeperator<true> TokenizerPlusEqual;
TokenMinusEqual = TokenizerTokenSeperator<true> TokenizerMinusEqual;
TokenStarEqual = TokenizerTokenSeperator<true> TokenizerStarEqual;
TokenPercentEqual = TokenizerTokenSeperator<true> TokenizerPercentEqual;
TokenLAngleLAngleEqual = TokenizerTokenSeperator<true> TokenizerLAngleLAngleEqual;
TokenRAngleRAngleEqual = TokenizerTokenSeperator<true> TokenizerRAngleRAngleEqual;
TokenRAngleRAngleRAngleEqual = TokenizerTokenSeperator<true> TokenizerRAngleRAngleRAngleEqual;
TokenAmpEqual = TokenizerTokenSeperator<true> TokenizerAmpEqual;
TokenPipeEqual = TokenizerTokenSeperator<true> TokenizerPipeEqual;
TokenCaretEqual = TokenizerTokenSeperator<true> TokenizerCaretEqual;
TokenArrow = TokenizerTokenSeperator<true> TokenizerArrow;
TokenFSlash = TokenizerTokenSeperator<true> TokenizerFSlash;
TokenFSlashEqual = TokenizerTokenSeperator<true> TokenizerFSlashEqual;

TokenRequiredSemicolon:Location =
    TokenizerTokenSeperator<true>
    {$$ = $_;}
    TokenizerSemicolon;

TokenSemicolon:Location =
    TokenRequiredSemicolon:semicolonLocation
    {$$ = semicolonLocation;}
    / &TokenizerTokenSeperatorWithLineTerminator
    {$$ = $_;}
    / &TokenRBrace
    {$$ = $_;}
    / &(
        TokenizerTokenSeperator<true>
        EOF
    )
    {$$ = $_;}
    ;

TokenSemicolonAfterDoWhile =
    TokenSemicolon
    / TokenizerTokenSeperator<true>
    ;

TokenIdentifierName:String =
    TokenizerTokenSeperator<true>
    TokenizerIdentifierName:value
    {$$ = value;};

TokenIdentifier<isModule:bool, isStrict:bool>:String =
    TokenizerTokenSeperator<true>
    !TokenizerReservedWord
    TokenizerIdentifierName:value
    {$$ = value;};

TokenIdentifierOrYield<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:String =
    &{
        if(canHaveYieldOperator || isStrict)
            $? = "yield not allowed here";
    }
    TokenYield
    {$$ = u"yield";}
    / TokenIdentifier:value
    {$$ = value;}
    ;

TokenLocation:Location =
    &(
        TokenizerTokenSeperator<true>
        {$$ = $_;}
    )
    ;

TokenNumericLiteral:String =
    TokenizerTokenSeperator<true>
    TokenizerNumericLiteral:value
    {$$ = value;}
    ;

TokenStringLiteral:String =
    TokenizerTokenSeperator<true>
    TokenizerStringLiteral:value
    {$$ = value;}
    ;

TokenRegularExpressionLiteral:BodyAndFlags =
    TokenizerTokenSeperator<true>
    TokenizerRegularExpressionLiteral:value
    {$$ = value;}
    ;

RegularExpressionLiteral:ExpressionPointer =
    TokenLocation:regExpLocation
    TokenRegularExpressionLiteral:regExp
    {$$ = arena.make<ast::ExpressionRegExpLiteral>(regExpLocation, regExp.body, regExp.flags);}
    ;

DirectivePrologue:DirectivePrologue =
    &(
        (
            TokenizerTokenSeperator<true>
            "'use strict'"
            TokenSemicolon
            {$$.useStrict = true;}
            / TokenizerTokenSeperator<true>
            "\"use strict\""
            TokenSemicolon
            {$$.useStrict = true;}
            / TokenStringLiteral
            TokenSemicolon
        )*
    )
    ;

IdentifierReference<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenLocation:nameLocation
    TokenIdentifierOrYield:name
    {$$ = arena.make<ast::ExpressionIdentifierReference>(nameLocation, name);}
    ;

BindingIdentifier<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:String =
    TokenIdentifierOrYield:name
    {$$ = std::move(name);}
    ;

FunctionExpression<isModule:bool, isStrict:bool>:ExpressionPointer =
    &{
        $? = "FunctionExpression not implemented";
#warning implement FunctionExpression
    };

GeneratorExpression<isModule:bool, isStrict:bool>:ExpressionPointer =
    &{
        $? = "GeneratorExpression not implemented";
#warning implement GeneratorExpression
    };

ClassExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ClassExpression not implemented";
#warning implement ClassExpression
    };

ParenthesizedExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    "("
    Expression<isModule, isStrict, true, canHaveYieldOperator>:expression
    ")"
    (
        &TokenizerTokenSeperatorWithLineTerminator
        / !TokenArrow
    )
    {$$ = expression;};

PrimaryExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenLocation:thisLocation
    TokenThis
    {$$ = arena.make<ast::ExpressionThis>(thisLocation);}
    / IdentifierReference:identifierReference
    {$$ = identifierReference;}
    / Literal:literal
    {$$ = literal;}
    / ArrayLiteral:arrayLiteral
    {$$ = arrayLiteral;}
    / ObjectLiteral:objectLiteral
    {$$ = objectLiteral;}
    / FunctionExpression:functionExpression
    {$$ = functionExpression;}
    / ClassExpression:classExpression
    {$$ = classExpression;}
    / GeneratorExpression:generatorExpression
    {$$ = generatorExpression;}
    / RegularExpressionLiteral:regularExpressionLiteral
    {$$ = regularExpressionLiteral;}
    / TemplateLiteral:templateLiteral
    {$$ = templateLiteral;}
    / ParenthesizedExpression:parenthesizedExpression
    {$$ = parenthesizedExpression;}
    ;

Literal:ExpressionPointer =
    TokenLocation:location
    (
        TokenNull
        {$$ = arena.make<ast::ExpressionNullLiteral>(location);}
        / TokenFalse
        {$$ = arena.make<ast::ExpressionBooleanLiteral>($_, false);}
        / TokenTrue
        {$$ = arena.make<ast::ExpressionBooleanLiteral>($_, true);}
        / TokenNumericLiteral:numericLiteral
        {$$ = arena.make<ast::ExpressionNumericLiteral>($_, value::StringHandle::toNumberValue(numericLiteral));}
        / TokenStringLiteral:stringLiteral
        {$$ = arena.make<ast::ExpressionStringLiteral>($_, stringLiteral);}
    )
    ;

ArrayLiteralElement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArrayLiteralElementPointer =
    &(
        TokenComma
        !TokenRBracket
    )
    {$$ = nullptr;}
    / TokenLocation:ellipsisLocation
    TokenEllipsis
    AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:spreadExpression
    {$$ = arena.make<ast::SpreadArrayLiteralElement>(ellipsisLocation, spreadExpression);}
    / TokenLocation:expressionLocation
    AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:expression
    {$$ = arena.make<ast::ExpressionArrayLiteralElement>(expressionLocation, expression);}
    ;

ArrayLiteralElementList<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArrayLiteralElementList =
    (
        ArrayLiteralElement:element
        TokenComma
        {$$.push_back(element);}
    )*
    (
        ArrayLiteralElement:lastElement
        {$$.push_back(lastElement);}
    )?
    ;

ArrayLiteral<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenLocation:location
    TokenLBracket
    ArrayLiteralElementList:elements
    TokenRBracket
    {$$ = arena.make<ast::ExpressionArrayLiteral>(location, std::move(elements));}
    ;

ObjectLiteral<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ObjectLiteral not implemented";
#warning implement ObjectLiteral
    };

PropertyName<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:PropertyNamePointer =
    TokenLocation:location
    (
        IdentifierName:identifierName
        {$$ = arena.make<ast::IdentifierPropertyName>(location, std::move(identifierName));}
        / TokenStringLiteral:stringLiteral
        {$$ = arena.make<ast::StringPropertyName>(location, std::move(stringLiteral));}
        / TokenNumericLiteral:numericLiteral
        {$$ = arena.make<ast::NumericPropertyName>(location, value::StringHandle::toNumberValue(numericLiteral));}
        / TokenLBracket
        AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:expression
        TokenRBracket
        {$$ = arena.make<ast::ComputedPropertyName>(location, expression);}
    );

Initializer<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenEqual
    AssignmentExpression:expression
    {$$ = expression;}
    ;

TemplateLiteral<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionTemplateLiteralPointer =
    TokenLocation:location
    TokenNoSubstitutionTemplate:noSubstitutionTemplate
    {
        $$ = arena.make<ast::ExpressionTemplateLiteral>(location,
                                                        ast::TemplateString(noSubstitutionTemplate.raw,
                                                                       noSubstitutionTemplate.cooked));
    }
    / TokenLocation:headLocation
    TokenTemplateHead:first
    TemplateLiteralRest:rest
    {
        $$ = arena.make<ast::ExpressionTemplateLiteral>(headLocation, ast::TemplateString(first.raw, first.cooked), std::move(rest));
    }
    ;

TemplateLiteralRest<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:TemplateRest =
    (
        Expression<isModule, isStrict, true, canHaveYieldOperator>:expression
        TokenTemplateMiddle:middle
        {$$.emplace_back(expression, ast::TemplateString(middle.raw, middle.cooked));}
    )*
    Expression<isModule, isStrict, true, canHaveYieldOperator>:lastExpression
    TokenTemplateTail:tail
    {$$.emplace_back(lastExpression, ast::TemplateString(tail.raw, tail.cooked));}
    ;

ArrowFunction<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    &{
        $? = "ArrowFunction not implemented";
#warning implement ArrowFunction
    };

YieldExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool>:ExpressionPointer =
    &{
        $? = "YieldExpression not implemented";
#warning implement YieldExpression
    };

MemberExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    (
        TokenNew
        MemberExpression:constructor
        TokenLocation:newLocation
        Arguments:newArguments
        {$$ = arena.make<ast::ExpressionNew>(newLocation, constructor, std::move(newArguments));}
        / SuperProperty:superProperty
        {$$ = superProperty;}
        / MetaProperty:metaProperty
        {$$ = metaProperty;}
        / PrimaryExpression:primaryExpression
        {$$ = primaryExpression;}
    )
    (
        TokenLocation:periodLocation
        TokenPeriod
        TokenLocation:identifierNameLocation
        TokenIdentifierName:identifierName
        {$$ = arena.make<ast::ExpressionMember>(periodLocation, $$, arena.make<ast::ExpressionStringLiteral>(identifierNameLocation, identifierName));}
        / TokenLocation:lBracketLocation
        TokenLBracket
        Expression<isModule, isStrict, true, canHaveYieldOperator>:nameExpression
        TokenRBracket
        {$$ = arena.make<ast::ExpressionMember>(lBracketLocation, $$, nameExpression);}
        / TokenLocation:templateLiteralLocation
        TemplateLiteral:templateLiteral
        {$$ = arena.make<ast::ExpressionTemplateCall>(templateLiteralLocation, $$, templateLiteral);}
    )*
    ;

SuperProperty<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenSuper
    TokenLocation:periodLocation
    TokenPeriod
    TokenIdentifierName:name
    {$$ = arena.make<ast::ExpressionSuperMember>(periodLocation, arena.make<ast::ExpressionStringLiteral>($_, name));}
    / TokenSuper
    TokenLocation:lBracketLocation
    TokenLBracket
    Expression<isModule, isStrict, true, canHaveYieldOperator>:nameExpression
    TokenRBracket
    {$$ = arena.make<ast::ExpressionSuperMember>(lBracketLocation, nameExpression);}
    ;

MetaProperty:ExpressionPointer =
    NewTarget:newTarget
    {$$ = newTarget;}
    ;

NewTarget:ExpressionPointer =
    TokenNew
    TokenLocation:newTargetLocation
    TokenPeriod
    TokenTarget
    {$$ = arena.make<ast::ExpressionNewTarget>(newTargetLocation);}
    ;

NewExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    MemberExpression:memberExpression
    {$$ = memberExpression;}
    / TokenLocation:newLocation
    TokenNew
    NewExpression:newExpression
    {$$ = arena.make<ast::ExpressionNew>(newLocation, newExpression);}
    ;

CallExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    (
        SuperCall:superCall
        {$$ = superCall;}
        / MemberExpression:memberExpression
        TokenLocation:firstCallLocation
        Arguments:firstArguments
        {$$ = arena.make<ast::ExpressionCall>(firstCallLocation, memberExpression, std::move(firstArguments));}
    )
    (
        TokenLocation:callLocation
        Arguments:arguments
        {$$ = arena.make<ast::ExpressionCall>(callLocation, $$, std::move(firstArguments));}
        / TokenLocation:periodLocation
        TokenPeriod
        TokenLocation:identifierNameLocation
        TokenIdentifierName:identifierName
        {$$ = arena.make<ast::ExpressionMember>(periodLocation, $$, arena.make<ast::ExpressionStringLiteral>(identifierNameLocation, identifierName));}
        / TokenLocation:lBracketLocation
        TokenLBracket
        Expression<isModule, isStrict, true, canHaveYieldOperator>:nameExpression
        TokenRBracket
        {$$ = arena.make<ast::ExpressionMember>(lBracketLocation, $$, nameExpression);}
        / TokenLocation:templateLiteralLocation
        TemplateLiteral:templateLiteral
        {$$ = arena.make<ast::ExpressionTemplateCall>(templateLiteralLocation, $$, templateLiteral);}
    )*
    ;

SuperCall<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenSuper
    TokenLocation:callLocation
    Arguments:arguments
    {$$ = arena.make<ast::ExpressionSuperCall>(callLocation, std::move(arguments));}
    ;

Arguments<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArgumentList =
    TokenLParen
    (
        ArgumentList:retval
        {$$ = std::move(retval);}
    )?
    TokenRParen
    ;

Argument<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArgumentPointer =
    TokenLocation:expressionLocation
    AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:expression
    {$$ = arena.make<ast::ArgumentExpression>(expressionLocation, expression);}
    / TokenLocation:ellipsisLocation
    TokenEllipsis
    AssignmentExpression<isModule, isStrict, true, canHaveYieldOperator>:spread
    {$$ = arena.make<ast::ArgumentSpread>(ellipsisLocation, spread);}
    ;

ArgumentList<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ArgumentList =
    (
        Argument:argument
        {$$.push_back(argument);}
    )+
    ;

LeftHandSideExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    CallExpression:callExpression
    {$$ = callExpression;}
    / NewExpression:newExpression
    {$$ = newExpression;}
    ;

PostfixExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    LeftHandSideExpression:expression
    {$$ = expression;}
    (
        !TokenizerTokenSeperatorWithLineTerminator
        TokenLocation:incLocation
        TokenPlusPlus
        {$$ = arena.make<ast::ExpressionPostfixIncrement>(incLocation, $$);}
        / !TokenizerTokenSeperatorWithLineTerminator
        TokenLocation:decLocation
        TokenMinusMinus
        {$$ = arena.make<ast::ExpressionPostfixDecrement>(decLocation, $$);}
    )?
    ;

UnaryExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    TokenLocation:deleteLocation
    TokenDelete
    UnaryExpression:deleteExpression
    {$$ = arena.make<ast::ExpressionDelete>(deleteLocation, deleteExpression);}
    / TokenLocation:voidLocation
    TokenVoid
    UnaryExpression:voidExpression
    {$$ = arena.make<ast::ExpressionVoid>(voidLocation, voidExpression);}
    / TokenLocation:typeOfLocation
    TokenTypeOf
    UnaryExpression:typeOfExpression
    {$$ = arena.make<ast::ExpressionTypeOf>(typeOfLocation, typeOfExpression);}
    / TokenLocation:incLocation
    TokenPlusPlus
    UnaryExpression:incExpression
    {$$ = arena.make<ast::ExpressionPrefixIncrement>(incLocation, incExpression);}
    / TokenLocation:decLocation
    TokenMinusMinus
    UnaryExpression:decExpression
    {$$ = arena.make<ast::ExpressionPrefixDecrement>(decLocation, decExpression);}
    / TokenLocation:plusLocation
    TokenPlus
    UnaryExpression:unaryPlusExpression
    {$$ = arena.make<ast::ExpressionUnaryPlus>(plusLocation, unaryPlusExpression);}
    / TokenLocation:minusLocation
    TokenMinus
    UnaryExpression:unaryMinusExpression
    {$$ = arena.make<ast::ExpressionUnaryMinus>(minusLocation, unaryMinusExpression);}
    / TokenLocation:tildeLocation
    TokenTilde
    UnaryExpression:bitwiseNotExpression
    {$$ = arena.make<ast::ExpressionBitwiseNot>(tildeLocation, bitwiseNotExpression);}
    / TokenLocation:notLocation
    TokenEMark
    UnaryExpression:logicalNotExpression
    {$$ = arena.make<ast::ExpressionLogicalNot>(notLocation, logicalNotExpression);}
    / PostfixExpression:expression
    {$$ = expression;}
    ;

MultiplicativeExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    UnaryExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:multiplyLocation
        TokenStar
        UnaryExpression:multiply
        {$$ = arena.make<ast::ExpressionMultiply>(multiplyLocation, $$, multiply);}
        / TokenLocation:divideLocation
        TokenFSlash
        UnaryExpression:divide
        {$$ = arena.make<ast::ExpressionDivide>(divideLocation, $$, divide);}
        / TokenLocation:modulusLocation
        TokenPercent
        UnaryExpression:modulus
        {$$ = arena.make<ast::ExpressionModulus>(modulusLocation, $$, modulus);}
    )*
    ;

AdditiveExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    MultiplicativeExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:plusLocation
        TokenPlus
        MultiplicativeExpression:plus
        {$$ = arena.make<ast::ExpressionPlus>(plusLocation, $$, plus);}
        / TokenLocation:minusLocation
        TokenMinus
        MultiplicativeExpression:minus
        {$$ = arena.make<ast::ExpressionMinus>(minusLocation, $$, minus);}
    )*
    ;

ShiftExpression<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    AdditiveExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:lShiftLocation
        TokenLAngleLAngle
        AdditiveExpression:lShift
        {$$ = arena.make<ast::ExpressionLShift>(lShiftLocation, $$, lShift);}
        / TokenLocation:arShiftLocation
        TokenRAngleRAngle
        AdditiveExpression:arShift
        {$$ = arena.make<ast::ExpressionARShift>(arShiftLocation, $$, arShift);}
        / TokenLocation:urShiftLocation
        TokenRAngleRAngleRAngle
        AdditiveExpression:urShift
        {$$ = arena.make<ast::ExpressionURShift>(urShiftLocation, $$, urShift);}
    )*
    ;

RelationalExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    ShiftExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:ltLocation
        TokenLAngle
        ShiftExpression:compareLT
        {$$ = arena.make<ast::ExpressionCompareLT>(ltLocation, $$, compareLT);}
        / TokenLocation:gtLocation
        TokenRAngle
        ShiftExpression:compareGT
        {$$ = arena.make<ast::ExpressionCompareGT>(gtLocation, $$, compareGT);}
        / TokenLocation:leLocation
        TokenLAngleEqual
        ShiftExpression:compareLE
        {$$ = arena.make<ast::ExpressionCompareLE>(leLocation, $$, compareLE);}
        / TokenLocation:geLocation
        TokenRAngleEqual
        ShiftExpression:compareGE
        {$$ = arena.make<ast::ExpressionCompareGE>(geLocation, $$, compareGE);}
        / TokenLocation:instanceOfLocation
        TokenInstanceOf
        ShiftExpression:instanceOfExpression
        {$$ = arena.make<ast::ExpressionInstanceOf>(instanceOfLocation, $$, instanceOfExpression);}
        / &{
            if(!canHaveInOperator)
                $? = "in not allowed here";
        } 
        TokenLocation:inLocation
        TokenIn
        ShiftExpression:inExpression
        {$$ = arena.make<ast::ExpressionIn>(inLocation, $$, inExpression);}
    )*
    ;

EqualityExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    RelationalExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:eqLocation
        TokenEqualEqual
        RelationalExpression:compareEq
        {$$ = arena.make<ast::ExpressionCompareEq>(eqLocation, $$, compareEq);}
        / TokenLocation:neLocation
        TokenEMarkEqual
        RelationalExpression:compareNE
        {$$ = arena.make<ast::ExpressionCompareNE>(neLocation, $$, compareNE);}
        / TokenLocation:strictEqLocation
        TokenEqualEqualEqual
        RelationalExpression:compareStrictEq
        {$$ = arena.make<ast::ExpressionCompareStrictEq>(strictEqLocation, $$, compareStrictEq);}
        / TokenLocation:strictNELocation
        TokenEMarkEqualEqual
        RelationalExpression:compareStrictNE
        {$$ = arena.make<ast::ExpressionCompareStrictNE>(strictNELocation, $$, compareStrictNE);}
    )*
    ;

BitwiseANDExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    EqualityExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:location
        TokenAmp
        EqualityExpression:nextExpression
        {$$ = arena.make<ast::ExpressionBitwiseAnd>(location, $$, nextExpression);}
    )*
    ;

BitwiseXORExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    BitwiseANDExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:location
        TokenCaret
        BitwiseANDExpression:nextExpression
        {$$ = arena.make<ast::ExpressionBitwiseXor>(location, $$, nextExpression);}
    )*
    ;

BitwiseORExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    BitwiseXORExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:location
        TokenPipe
        BitwiseXORExpression:nextExpression
        {$$ = arena.make<ast::ExpressionBitwiseOr>(location, $$, nextExpression);}
    )*
    ;

LogicalANDExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    BitwiseORExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:location
        TokenAmpAmp
        BitwiseORExpression:nextExpression
        {$$ = arena.make<ast::ExpressionLogicalAnd>(location, $$, nextExpression);}
    )*
    ;

LogicalORExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    LogicalANDExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:location
        TokenPipePipe
        LogicalANDExpression:nextExpression
        {$$ = arena.make<ast::ExpressionLogicalOr>(location, $$, nextExpression);}
    )*
    ;

ConditionalExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    LogicalORExpression:condition
    {$$ = condition;}
    (
        TokenLocation:location
        TokenQMark
        AssignmentExpression:trueExpression
        TokenColon
        AssignmentExpression:falseExpression
        {$$ = arena.make<ast::ExpressionConditional>(location, condition, trueExpression, falseExpression);}
    )?;

AssignmentExpression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    ArrowFunction:arrowFunction
    {$$ = arrowFunction;}
    / &(
        TokenYield
        &{
            if(!canHaveYieldOperator)
                $? = "yield not allowed here";
        }
    )
    YieldExpression:yieldExpression
    {$$ = yieldExpression;}
    / LeftHandSideExpression:leftHandSideExpression
    (
        TokenLocation:location
        TokenEqual
        AssignmentExpression:assignmentExpression
        {$$ = arena.make<ast::AssignmentExpression>(location, leftHandSideExpression, assignmentExpression);}
        / TokenLocation:starLocation
        TokenStarEqual
        AssignmentExpression:multiplyAssignmentExpression
        {$$ = arena.make<ast::MultiplyAssignmentExpression>(starLocation, leftHandSideExpression, multiplyAssignmentExpression);}
        / TokenLocation:fSlashLocation
        TokenFSlashEqual
        AssignmentExpression:divideAssignmentExpression
        {$$ = arena.make<ast::DivideAssignmentExpression>(fSlashLocation, leftHandSideExpression, divideAssignmentExpression);}
        / TokenLocation:percentLocation
        TokenPercentEqual
        AssignmentExpression:modulusAssignmentExpression
        {$$ = arena.make<ast::ModulusAssignmentExpression>(percentLocation, leftHandSideExpression, modulusAssignmentExpression);}
        / TokenLocation:plusLocation
        TokenPlusEqual
        AssignmentExpression:addAssignmentExpression
        {$$ = arena.make<ast::AddAssignmentExpression>(plusLocation, leftHandSideExpression, addAssignmentExpression);}
        / TokenLocation:minusLocation
        TokenMinusEqual
        AssignmentExpression:subtractAssignmentExpression
        {$$ = arena.make<ast::SubtractAssignmentExpression>(minusLocation, leftHandSideExpression, subtractAssignmentExpression);}
        / TokenLocation:lShiftLocation
        TokenLAngleLAngleEqual
        AssignmentExpression:lShiftAssignmentExpression
        {$$ = arena.make<ast::LShiftAssignmentExpression>(lShiftLocation, leftHandSideExpression, lShiftAssignmentExpression);}
        / TokenLocation:arShiftLocation
        TokenRAngleRAngleEqual
        AssignmentExpression:arShiftAssignmentExpression
        {$$ = arena.make<ast::ARShiftAssignmentExpression>(arShiftLocation, leftHandSideExpression, arShiftAssignmentExpression);}
        / TokenLocation:urShiftLocation
        TokenRAngleRAngleRAngleEqual
        AssignmentExpression:urShiftAssignmentExpression
        {$$ = arena.make<ast::URShiftAssignmentExpression>(urShiftLocation, leftHandSideExpression, urShiftAssignmentExpression);}
        / TokenLocation:andLocation
        TokenAmpEqual
        AssignmentExpression:andAssignmentExpression
        {$$ = arena.make<ast::AndAssignmentExpression>(andLocation, leftHandSideExpression, andAssignmentExpression);}
        / TokenLocation:xorLocation
        TokenCaretEqual
        AssignmentExpression:xorAssignmentExpression
        {$$ = arena.make<ast::XorAssignmentExpression>(xorLocation, leftHandSideExpression, xorAssignmentExpression);}
        / TokenLocation:orLocation
        TokenPipeEqual
        AssignmentExpression:orAssignmentExpression
        {$$ = arena.make<ast::OrAssignmentExpression>(orLocation, leftHandSideExpression, orAssignmentExpression);}
    )
    / ConditionalExpression:conditionalExpression
    {$$ = conditionalExpression;};

Expression<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:ExpressionPointer =
    AssignmentExpression:firstExpression
    {$$ = firstExpression;}
    (
        TokenLocation:location
        TokenComma
        AssignmentExpression:nextExpression
        {$$ = arena.make<ast::ExpressionComma>(location, $$, nextExpression);}
    )*
    !TokenComma
    ;

ContinueStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

BreakStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

ReturnStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

WithStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

LabelledStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

ThrowStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

TryStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

DebuggerStatement:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

Statement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    BlockStatement:blockStatement
    {$$ = blockStatement;}
    / ReturnStatement:returnStatement
    &{
        if(!canHaveReturnStatement)
        {
            $? = "return statement not allowed here";
        }
        else
        {
            $$ = returnStatement;
        }
    }
    / VariableStatement:variableStatement
    {$$ = variableStatement;}
    / EmptyStatement:emptyStatement
    {$$ = emptyStatement;}
    / ExpressionStatement:expressionStatement
    {$$ = expressionStatement;}
    / IfStatement:ifStatement
    {$$ = ifStatement;}
    / BreakableStatement:breakableStatement
    {$$ = breakableStatement;}
    / ContinueStatement:continueStatement
    {$$ = continueStatement;}
    / BreakStatement:breakStatement
    {$$ = breakStatement;}
    / WithStatement:withStatement
    {$$ = withStatement;}
    / LabelledStatement:labelledStatement
    {$$ = labelledStatement;}
    / ThrowStatement:throwStatement
    {$$ = throwStatement;}
    / TryStatement:tryStatement
    {$$ = tryStatement;}
    / DebuggerStatement:debuggerStatement
    {$$ = debuggerStatement;}
    ;

Declaration<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    HoistableDeclaration<isModule, isStrict, canHaveYieldOperator, false>:hoistableDeclaration
    {$$ = hoistableDeclaration;}
    / ClassDeclaration<isModule, isStrict, canHaveYieldOperator, false>:classDeclaration
    {$$ = classDeclaration;}
    / LexicalDeclaration<isModule, isStrict, true, canHaveYieldOperator>:lexicalDeclaration
    {$$ = lexicalDeclaration;}
    ;

HoistableDeclaration<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveEmptyName:bool>:StatementPointer =
    FunctionDeclaration:functionDeclaration
    {$$ = functionDeclaration;}
    / GeneratorDeclaration:generatorDeclaration
    {$$ = generatorDeclaration;}
    ;

FunctionDeclaration<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveEmptyName:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

GeneratorDeclaration<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveEmptyName:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

ClassDeclaration<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveEmptyName:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

IterationStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

SwitchStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    &{
        $? = "not implemented";
#warning implement
    }
    ;

BreakableStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    SwitchStatement:switchStatement
    {$$ = switchStatement;}
    / IterationStatement:iterationStatement
    {$$ = iterationStatement;}
    ;

BlockStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    Block:block
    {$$ = block;}
    ;

Block<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    TokenLocation:lBraceLocation
    TokenLBrace
    StatementList:statementList?
    {$$ = arena.make<ast::StatementBlock>(lBraceLocation, std::move(statementList));}
    TokenRBrace
    ;

StatementList<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementList =
    (
        StatementListItem:statementListItem
        {$$.push_back(statementListItem);}
    )+
    ;

StatementListItem<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    Statement:statement
    {$$ = statement;}
    / Declaration:declaration
    {$$ = declaration;}
    ;

LexicalDeclaration<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:StatementPointer =
    TokenLocation:declarationLocation
    (
        TokenLet
        BindingList:letBindingList
        {$$ = arena.make<ast::DeclarationLet>(declarationLocation, std::move(letBindingList));}
        / TokenConst
        BindingList:constBindingList
        {$$ = arena.make<ast::DeclarationConst>(declarationLocation, std::move(constBindingList));}
    )
    TokenSemicolon
    ;

BindingList<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:BindingList =
    LexicalBinding:firstBinding
    {$$.push_back(firstBinding);}
    (
        TokenComma
        LexicalBinding:nextBinding
        {$$.push_back(nextBinding);}
    )*
    ;

LexicalBinding<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:bindingIdentifierLocation
    BindingIdentifier:bindingIdentifier
    (
        Initializer:idInitializer
        / {idInitializer = nullptr;}
    )
    {
        $$ = arena.make<ast::LexicalBinding>(bindingIdentifierLocation,
                                             arena.make<ast::BindingIdentifier>(bindingIdentifierLocation,
                                                                               std::move(bindingIdentifier)),
                                             idInitializer);
    }
    / TokenLocation:bindingPatternLocation
    BindingPattern:bindingPattern
    Initializer:patternInitializer
    {$$ = arena.make<ast::LexicalBinding>(bindingPatternLocation, bindingPattern, patternInitializer);}
    ;

VariableStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    TokenLocation:location
    TokenVar
    VariableDeclarationList<isModule, isStrict, true, canHaveYieldOperator>:declarations
    TokenSemicolon
    {$$ = arena.make<ast::StatementVariable>(location, std::move(declarations));}
    ;

VariableDeclarationList<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:BindingList =
    VariableDeclaration:first
    {$$.push_back(first);}
    (
        TokenComma
        VariableDeclaration:next
        {$$.push_back(next);}
    )*
    ;

VariableDeclaration<isModule:bool, isStrict:bool, canHaveInOperator:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:bindingIdentifierLocation
    BindingIdentifier:bindingIdentifier
    (
        Initializer:idInitializer
        / {idInitializer = nullptr;}
    )
    {
        $$ = arena.make<ast::VariableDeclaration>(bindingIdentifierLocation,
                                                  arena.make<ast::BindingIdentifier>(bindingIdentifierLocation,
                                                                                     std::move(bindingIdentifier)),
                                                  idInitializer);
    }
    / TokenLocation:bindingPatternLocation
    BindingPattern:bindingPattern
    Initializer:patternInitializer
    {$$ = arena.make<ast::VariableDeclaration>(bindingPatternLocation, bindingPattern, patternInitializer);}
    ;

BindingPattern<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    ObjectBindingPattern:objectPattern
    {$$ = objectPattern;}
    / ArrayBindingPattern:arrayPattern
    {$$ = arrayPattern;}
    ;

ObjectBindingPattern<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:location
    TokenLBrace
    (
        BindingPropertyList:propertyList
        TokenComma?
    )?
    TokenRBrace
    {$$ = arena.make<ast::ObjectBindingPattern>(location, std::move(propertyList));}
    ;

ArrayBindingPattern<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:location
    TokenLBracket
    ArrayBindingElementList:elementList
    {$$ = arena.make<ast::ArrayBindingPattern>(location, std::move(elementList));}
    TokenRBracket
    ;

ArrayBindingElementList<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingList =
    (
        !(
            TokenComma
            TokenRBracket
        )
        (
            BindingElement:bindingElement
            / {bindingElement = nullptr;}
        )
        TokenComma
        {$$.push_back(bindingElement);}
    )*
    (
        BindingRestElement:restElement
        {$$.push_back(restElement);}
        / BindingElement:lastElement
        {$$.push_back(lastElement);}
    )?
    ;

BindingPropertyList<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingList =
    BindingProperty:firstProperty
    {$$.push_back(firstProperty);}
    (
        TokenComma
        BindingProperty:nextProperty
        {$$.push_back(nextProperty);}
    )*
    ;

BindingProperty<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    PropertyName:propertyName
    TokenLocation:location
    TokenColon
    BindingElement:element
    {$$ = arena.make<ast::BindingProperty>(location, propertyName, element);}
    / SingleNameBinding:singleNameBinding
    {$$ = singleNameBinding;}
    ;

BindingElement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:location
    BindingPattern:bindingPattern
    (
        Initializer<isModule, isStrict, true, canHaveYieldOperator>:initializer
        / {initializer = nullptr;}
    )
    {$$ = arena.make<ast::BindingElement>(location, bindingPattern, initializer);}
    / SingleNameBinding:singleNameBinding
    {$$ = singleNameBinding;}
    ;

BindingRestElement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:location
    TokenEllipsis
    BindingIdentifier:name
    {$$ = arena.make<ast::BindingRestElement>(location, std::move(name));}
    ;

SingleNameBinding<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:BindingPointer =
    TokenLocation:location
    BindingIdentifier:name
    (
        Initializer<isModule, isStrict, true, canHaveYieldOperator>:initializer
        / {initializer = nullptr;}
    )
    {$$ = arena.make<ast::SingleNameBinding>(location, std::move(name), initializer);}
    ;

EmptyStatement:StatementPointer =
    TokenLocation:semicolonLocation
    TokenRequiredSemicolon
    {$$ = arena.make<ast::StatementEmpty>(semicolonLocation);}
    ;

ExpressionStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool>:StatementPointer =
    !TokenLBrace
    !TokenFunction
    !TokenClass
    !(TokenLet TokenLBracket)
    TokenLocation:expressionLocation
    Expression<isModule, isStrict, true, canHaveYieldOperator>:expression
    TokenSemicolon
    {$$ = arena.make<ast::StatementExpression>(expressionLocation, expression);}
    ;

IfStatement<isModule:bool, isStrict:bool, canHaveYieldOperator:bool, canHaveReturnStatement:bool>:StatementPointer =
    TokenLocation:ifLocation
    TokenIf
    TokenLParen
    Expression<isModule, isStrict, true, canHaveYieldOperator>:condition
    TokenRParen
    Statement:thenPart
    (
        !TokenElse
        {$$ = arena.make<ast::StatementIf>(ifLocation, condition, thenPart, nullptr);}
        / TokenElse
        Statement:elsePart
        {$$ = arena.make<ast::StatementIf>(ifLocation, condition, thenPart, elsePart);}
    )
    ;

Script:StatementList =
    (
        ScriptBody:scriptBody
        {$$ = std::move(scriptBody);}
    )?
    TokenizerTokenSeperator<true>
    EOF
    ;

ScriptBody:StatementList =
    DirectivePrologue:directivePrologue
    (
        &{
            if(directivePrologue.useStrict)
                $? = "missing statement";
        }
        StatementList<false, false, false, false>:statementList
        {$$ = std::move(statementList);}
        / &{
            if(!directivePrologue.useStrict)
                $? = "missing statement";
        }
        StatementList<false, true, false, false>:strictStatementList
        {$$ = std::move(strictStatementList);}
    )
    ;



