code license {
/*
 * Copyright (C) 2012-2016 Jacob R. Lifshay
 * This file is part of Voxels.
 *
 * Voxels is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Voxels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Voxels; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 */

// to regenerate this file, use https://github.com/programmerjake/peg_parser_generator
// command: peg_parser_generator parser_imp.peg
}

namespace javascript_tasklets::parser;

code header {
#include "../string.h"
#include <memory>
#include "ast/node.h"
#include "ast/expression.h"
#include "ast/expression_this.h"
#include "ast/arena.h"

namespace javascript_tasklets
{
namespace parser
{
struct RawAndCookedString final
{
    String raw;
    String cooked;
    RawAndCookedString() : raw(), cooked()
    {
    }
    RawAndCookedString(String raw) : raw(raw), cooked(std::move(raw))
    {
    }
    RawAndCookedString(String raw, String cooked) : raw(std::move(raw)), cooked(std::move(cooked))
    {
    }
};

struct RawStringAndChar final
{
    String raw;
    char32_t ch;
    RawStringAndChar() : raw(), ch()
    {
    }
    RawStringAndChar(String raw, char32_t ch) : raw(std::move(raw)), ch(ch)
    {
    }
};

struct BodyAndFlags final
{
    String body;
    String flags;
    BodyAndFlags() : body(), flags()
    {
    }
    BodyAndFlags(String body, String flags) : body(std::move(body)), flags(std::move(flags))
    {
    }
};

typedef ast::Node *NodePointer;
typedef ast::Expression *ExpressionPointer;
}
}
}

code class {
public:
    ast::Arena arena = ast::Arena();
}

code source {
#include "../character_properties.h"
}

typedef unsigned unsigned;
typedef bool bool;
typedef String String;
typedef RawAndCookedString RawAndCookedString;
typedef RawStringAndChar RawStringAndChar;
typedef BodyAndFlags BodyAndFlags;
typedef ExpressionPointer ExpressionPointer;
typedef NodePointer NodePointer;

TokenizerHexDigitValue:unsigned = 
    [^]:ch
    &{
        auto digitValue = character_properties::javascriptDigitValue(ch);
        if(digitValue >= 0 && digitValue < 0x10)
            $$ = digitValue;
        else
            $? = "missing hex digit";
    };

TokenizerLineTerminatorSequence:char = "\r\n" {$$ = U'\n';}
                                     / "\r" {$$ = U'\n';}
                                     / [^]:char1
                                     &{
                                         $$ = char1;
                                         if(!character_properties::javascriptLineTerminator($$))
                                             $? = "expected a line terminator";
                                     };

TokenizerComment<lineTerminatorAllowed:bool> =
    TokenizerMultiLineComment
    / TokenizerSingleLineComment;

TokenizerMultiLineComment<lineTerminatorAllowed:bool>:bool =
    "/*"
    {$$ = false;}
    (
        !"*/"
        (
            TokenizerLineTerminatorSequence
            &{
                if(!lineTerminatorAllowed)
                    $? = "line terminator not allowed here";
                $$ = true;
            }
            / !TokenizerLineTerminatorSequence
            [^]
        )
    )*
    "*/";

TokenizerSingleLineComment = "//" (!TokenizerLineTerminatorSequence [^])*;

TokenizerTokenSeperator<lineTerminatorAllowed:bool> = 
    (
        TokenizerMultiLineComment
        / TokenizerSingleLineComment
        / TokenizerLineTerminatorSequence
        &{
            if(!lineTerminatorAllowed)
                $? = "line terminator not allowed here";
        }
        / !TokenizerLineTerminatorSequence
        [^]:ch
        &{
            if(!character_properties::javascriptWhiteSpace(ch))
                $? = "not a whitespace character";
        }
    )*;

TokenizerTokenSeperatorWithLineTerminator = 
    TokenizerTokenSeperator<false>
    (
        TokenizerMultiLineComment<true>:hasLineTerminator
        &{
            if(!hasLineTerminator)
                $? = "missing line terminator";
        }
        / TokenizerLineTerminatorSequence
    );
        

TokenizerUnicodeEscapeSequence:RawStringAndChar = "u" {$$ = RawStringAndChar(u"u", 0);} (
    "{"
    {$$.raw += u"{";}
    (
        [^]:digit
        &{
            auto digitValue = character_properties::javascriptDigitValue(digit);
            if(digitValue < 0 || digitValue >= 0x10)
                $? = "missing hex digit";
            else
            {
                $$.ch = $$.ch * 0x10 + digitValue;
                $$.raw = appendCodePoint(std::move($$.raw), digit);
            }
            if($$.ch > 0x10FFFF)
                $? = "unicode escape value is too big";
        }
    )+
    "}"
    {$$.raw += u"}";}
    / [^]:digit1
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit1);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit1);
          }
      }
      [^]:digit2
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit2);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit2);
          }
      }
      [^]:digit3
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit3);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit3);
          }
      }
      [^]:digit4
      &{
          auto digitValue = character_properties::javascriptDigitValue(digit4);
          if(digitValue < 0 || digitValue >= 0x10)
              $? = "missing hex digit";
          else
          {
              $$.ch = $$.ch * 0x10 + digitValue;
              $$.raw = appendCodePoint(std::move($$.raw), digit4);
          }
      }
    );

TokenizerUnicodeEscapeOrChar:char = "\\" TokenizerUnicodeEscapeSequence:escape {$$ = escape.ch;}
                                  / [^]:ch {$$ = ch;};

TokenizerEscapelessIdentifierStart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdStart(ch))
            $? = "expected identifier start";
        else
            $$ = ch;
    };

TokenizerEscapelessIdentifierPart:char =
    [^]:ch
    &{
        if(!character_properties::javascriptIdContinue(ch))
            $? = "expected identifier part";
        else
            $$ = ch;
    };

TokenizerIdentifierName:String =
    TokenizerUnicodeEscapeOrChar:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = startChar;
    }
    (
        TokenizerUnicodeEscapeOrChar:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = continueChar;
        }
    )*
    !"\\";

TokenizerEscapelessIdentifierName:String =
    [^]:startChar
    &{
        if(!character_properties::javascriptIdStart(startChar))
            $? = "expected identifier start";
        else
            $$ = appendCodePoint(u"", startChar);
    }
    (
        [^]:continueChar
        &{
            if(!character_properties::javascriptIdContinue(continueChar))
                $? = "expected identifier continue";
            else
                $$ = appendCodePoint(std::move($$), continueChar);
        }
    )*
    !"\\";

TokenizerReservedWord<isModule:bool, isStrict:bool> = TokenizerKeyword / TokenizerFutureReservedWord / TokenizerNullLiteral / TokenizerBooleanLiteral;

TokenizerAwait = "await" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerBreak = "break" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCase = "case" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerCatch = "catch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerClass = "class" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerConst = "const" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerContinue = "continue" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDebugger = "debugger" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDefault = "default" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDelete = "delete" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerDo = "do" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerElse = "else" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerEnum = "enum" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExport = "export" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerExtends = "extends" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFalse = "false" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFinally = "finally" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFor = "for" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerFunction = "function" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIf = "if" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImplements = "implements" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerImport = "import" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerIn = "in" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInstanceOf = "instanceof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerInterface = "interface" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNew = "new" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerNull = "null" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPackage = "package" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPrivate = "private" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerProtected = "protected" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerPublic = "public" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerReturn = "return" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSuper = "super" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerSwitch = "switch" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThis = "this" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerThrow = "throw" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTrue = "true" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTry = "try" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerTypeOf = "typeof" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVar = "var" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerVoid = "void" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWhile = "while" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerWith = "with" !"\\" !TokenizerEscapelessIdentifierPart;
TokenizerYield = "yield" !"\\" !TokenizerEscapelessIdentifierPart;

TokenizerKeyword = TokenizerBreak
                 / TokenizerCase
                 / TokenizerCatch
                 / TokenizerClass
                 / TokenizerConst
                 / TokenizerContinue
                 / TokenizerDebugger
                 / TokenizerDefault
                 / TokenizerDelete
                 / TokenizerDo
                 / TokenizerElse
                 / TokenizerExport
                 / TokenizerExtends
                 / TokenizerFinally
                 / TokenizerFor
                 / TokenizerFunction
                 / TokenizerIf
                 / TokenizerImport
                 / TokenizerIn
                 / TokenizerInstanceOf
                 / TokenizerNew
                 / TokenizerReturn
                 / TokenizerSuper
                 / TokenizerSwitch
                 / TokenizerThis
                 / TokenizerThrow
                 / TokenizerTry
                 / TokenizerTypeOf
                 / TokenizerVar
                 / TokenizerVoid
                 / TokenizerWhile
                 / TokenizerWith
                 / TokenizerYield;

TokenizerFutureReservedWord<isModule:bool, isStrict:bool> =
    TokenizerAwait &{if(isModule) $? = "not in a module";}
    / TokenizerEnum
    / &{if(!isStrict) $? = "not strict";}
    (
        TokenizerImplements
        / TokenizerInterface
        / TokenizerPackage
        / TokenizerPrivate
        / TokenizerProtected
        / TokenizerPublic
    );

TokenizerNullLiteral = TokenizerNull;

TokenizerBooleanLiteral:bool = TokenizerTrue {$$ = true;} / TokenizerFalse {$$ = false;};

TokenizerLBrace = "{";
TokenizerRBrace = "}";
TokenizerLParen = "(";
TokenizerRParen = ")";
TokenizerLBracket = "[";
TokenizerRBracket = "]";
TokenizerPeriod = !"..." "." ![0-9];
TokenizerEllipsis = "...";
TokenizerSemicolon = ";";
TokenizerComma = ",";
TokenizerLAngle = "<" ![<=];
TokenizerRAngle = ">" ![>=];
TokenizerLAngleEqual = "<=";
TokenizerRAngleEqual = ">=";
TokenizerEqualEqual = "==" !"=";
TokenizerEMarkEqual = "!=" !"=";
TokenizerEqualEqualEqual = "===";
TokenizerEMarkEqualEqual = "!==";
TokenizerPlus = "+" ![+=];
TokenizerMinus = "-" ![\-=];
TokenizerStar = "*" ![*=];
TokenizerStarStar = "**";
TokenizerPercent = "%" !"=";
TokenizerPlusPlus = "++";
TokenizerMinusMinus = "--";
TokenizerLAngleLAngle = "<<" !"=";
TokenizerRAngleRAngle = ">>" ![>=];
TokenizerRAngleRAngleRAngle = ">>>" !"=";
TokenizerAmp = "&" ![&=];
TokenizerPipe = "|" ![|=];
TokenizerCaret = "^" !"=";
TokenizerEMark = "!" !"=";
TokenizerTilde = "~";
TokenizerAmpAmp = "&&";
TokenizerPipePipe = "||";
TokenizerQMark = "?";
TokenizerColon = ":";
TokenizerEqual = "=" ![=>];
TokenizerPlusEqual = "+=";
TokenizerMinusEqual = "-=";
TokenizerStarEqual = "*=";
TokenizerPercentEqual = "%=";
TokenizerLAngleLAngleEqual = "<<=";
TokenizerRAngleRAngleEqual = ">>=";
TokenizerRAngleRAngleRAngleEqual = ">>>=";
TokenizerAmpEqual = "&=";
TokenizerPipeEqual = "|=";
TokenizerCaretEqual = "^=";
TokenizerArrow = "=>";
TokenizerFSlash = "/" ![=/*];
TokenizerFSlashEqual = "/=";

TokenizerPunctuator = TokenizerLBrace
                    / TokenizerLParen
                    / TokenizerRParen
                    / TokenizerLBracket
                    / TokenizerRBracket
                    / TokenizerPeriod
                    / TokenizerEllipsis
                    / TokenizerSemicolon
                    / TokenizerComma
                    / TokenizerLAngle
                    / TokenizerRAngle
                    / TokenizerLAngleEqual
                    / TokenizerRAngleEqual
                    / TokenizerEqualEqual
                    / TokenizerEMarkEqual
                    / TokenizerEqualEqualEqual
                    / TokenizerEMarkEqualEqual
                    / TokenizerPlus
                    / TokenizerMinus
                    / TokenizerStar
                    / TokenizerStarStar
                    / TokenizerPercent
                    / TokenizerPlusPlus
                    / TokenizerMinusMinus
                    / TokenizerLAngleLAngle
                    / TokenizerRAngleRAngle
                    / TokenizerRAngleRAngleRAngle
                    / TokenizerAmp
                    / TokenizerPipe
                    / TokenizerCaret
                    / TokenizerEMark
                    / TokenizerTilde
                    / TokenizerAmpAmp
                    / TokenizerPipePipe
                    / TokenizerQMark
                    / TokenizerColon
                    / TokenizerEqual
                    / TokenizerPlusEqual
                    / TokenizerMinusEqual
                    / TokenizerStarEqual
                    / TokenizerPercentEqual
                    / TokenizerLAngleLAngleEqual
                    / TokenizerRAngleRAngleEqual
                    / TokenizerRAngleRAngleRAngleEqual
                    / TokenizerAmpEqual
                    / TokenizerPipeEqual
                    / TokenizerCaretEqual
                    / TokenizerArrow;

TokenizerDivPunctuator = TokenizerFSlash / TokenizerFSlashEqual;

TokenizerRightBracePunctuator = TokenizerRBrace;

TokenizerNumericLiteral:String = TokenizerDecimalLiteral:value0 {$$ = value0;}
                               / TokenizerBinaryIntegerLiteral:value1 {$$ = value1;}
                               / TokenizerOctalIntegerLiteral:value2 {$$ = value2;}
                               / TokenizerHexIntegerLiteral:value3 {$$ = value3;};

TokenizerDecimalLiteral:String = TokenizerDecimalIntegerLiteral:value0 {$$ = value0;}
                                 "." {$$ += u'.';}
                                 (
                                     TokenizerDecimalDigits:value1 {$$ += value1;}
                                 )?
                                 (
                                     TokenizerExponentPart:value2 {$$ += value2;}
                                 )?
                               / "." {$$ = u'.';}
                                 TokenizerDecimalDigits:value3 {$$ += value3;}
                                 (
                                     TokenizerExponentPart:value4 {$$ += value4;}
                                 )?
                               / TokenizerDecimalIntegerLiteral:value5 {$$ = value5;}
                                 TokenizerDecimalDigits:value6 {$$ += value6;}
                                 (
                                     TokenizerExponentPart:value7 {$$ += value7;}
                                 )?
                               ;

TokenizerDecimalIntegerLiteral:String =
    "0" {$$ = u"0";} ![0-9]
    / [1-9]:nonZeroDigit
    {$$ = appendCodePoint(u"", nonZeroDigit);}
    (TokenizerDecimalDigits:digits {$$ += digits;})?;

TokenizerDecimalDigits:String =
    {$$ = u"";}
    (
        [0-9]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerExponentPart:String =
    [eE]:exponentIndicator
    {$$ = appendCodePoint(u"", exponentIndicator);}
    TokenizerSignedInteger:signedInteger
    {$$ += signedInteger;}
    ;

TokenizerSignedInteger:String =
    {$$ = u"";}
    (
        [+\-]:sign
        {$$ = appendCodePoint(u"", sign);}
    )?
    TokenizerDecimalDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [bB]:binaryIndicator
    {$$ = appendCodePoint(std::move($$), binaryIndicator);}
    TokenizerBinaryDigits:digits
    {$$ += digits;}
    ;

TokenizerBinaryDigits:String =
    {$$ = u"";}
    (
        [01]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerOctalIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [oO]:octalIndicator
    {$$ = appendCodePoint(std::move($$), octalIndicator);}
    TokenizerOctalDigits:digits
    {$$ += digits;}
    ;

TokenizerOctalDigits:String =
    {$$ = u"";}
    (
        [0-7]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerHexIntegerLiteral:String =
    "0"
    {$$ = u"0";}
    [xX]:hexIndicator
    {$$ = appendCodePoint(std::move($$), hexIndicator);}
    TokenizerHexDigits:digits
    {$$ += digits;}
    ;

TokenizerHexDigits:String =
    {$$ = u"";}
    (
        [0-9a-fA-F]:digit
        {$$ = appendCodePoint(std::move($$), digit);}
    )+;

TokenizerStringLiteral:String =
    "\'"
    {$$ = u"";}
    (
        TokenizerSingleStringCharacters:characters1
        {$$ = characters1;}
    )?
    "\'"
    / "\""
    {$$ = u"";}
    (
        TokenizerDoubleStringCharacters:characters2
        {$$ = characters2;}
    )?
    "\"";

TokenizerSingleStringCharacters:String =
    TokenizerSingleStringCharacter:first
    {$$ = first;}
    (
        TokenizerSingleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerDoubleStringCharacters:String =
    TokenizerDoubleStringCharacter:first
    {$$ = first;}
    (
        TokenizerDoubleStringCharacter:next
        {$$ += next;}
    )*;

TokenizerSingleStringCharacter:String =
    !"\'"
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerDoubleStringCharacter:String =
    !"\""
    !"\\"
    !TokenizerLineTerminatorSequence
    [^]:ch
    {$$ = appendCodePoint(u"", ch);}
    / "\\" TokenizerEscapeSequence:escape
    {$$ = escape.cooked;}
    / TokenizerLineContinuation
    {$$ = u"";}
    ;

TokenizerLineContinuation:String = "\\" TokenizerLineTerminatorSequence:lineTerminator {$$ = appendCodePoint(u"\\", lineTerminator);};

TokenizerEscapeSequence:RawAndCookedString =
    "0"
    ![0-9]
    {$$ = RawAndCookedString(u"0", String(1, u'\0'));}
    / TokenizerCharacterEscapeSequence:characterEscape
    {$$ = characterEscape;}
    / TokenizerUnicodeEscapeSequence:unicodeEscape
    {$$ = RawAndCookedString(unicodeEscape.raw, appendCodePoint(u"", unicodeEscape.ch));}
    / TokenizerHexEscapeSequence:hexEscape
    {$$ = RawAndCookedString(hexEscape.raw, appendCodePoint(u"", hexEscape.ch));}
    ;

TokenizerHexEscapeSequence:RawStringAndChar = 
    "x"
    {$$ = RawStringAndChar(u"x", 0);}
    [^]:digit1
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit1);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit1);
        }
    }
    [^]:digit2
    &{
        auto digitValue = character_properties::javascriptDigitValue(digit2);
        if(digitValue < 0 || digitValue >= 0x10)
            $? = "missing hex digit";
        else
        {
            $$.ch = $$.ch * 0x10 + digitValue;
            $$.raw = appendCodePoint(std::move($$.raw), digit2);
        }
    }
    ;

TokenizerCharacterEscapeSequence:RawAndCookedString =
    TokenizerSingleEscapeCharacter:singleEscapeCharacter
    {$$ = singleEscapeCharacter;}
    / TokenizerNonEscapeCharacter:nonEscapeCharacter
    {$$ = RawAndCookedString(appendCodePoint(u"", nonEscapeCharacter));}
    ;

TokenizerSingleEscapeCharacter:RawAndCookedString =
    ['"\\]:char1
    {$$ = RawAndCookedString(appendCodePoint(u"", char1));}
    / "b"
    {$$ = RawAndCookedString(u"b", u"\b");}
    / "f"
    {$$ = RawAndCookedString(u"f", u"\f");}
    / "n"
    {$$ = RawAndCookedString(u"n", u"\n");}
    / "r"
    {$$ = RawAndCookedString(u"r", u"\r");}
    / "t"
    {$$ = RawAndCookedString(u"t", u"\t");}
    / "v"
    {$$ = RawAndCookedString(u"v", u"\v");}
    ;

TokenizerNonEscapeCharacter:char =
    !TokenizerLineTerminatorSequence
    ![0-9xu]
    !TokenizerSingleEscapeCharacter
    [^]:ch
    {$$ = ch;}
    ;

TokenizerRegularExpressionLiteral:BodyAndFlags =
    "/"
    TokenizerRegularExpressionBody:body
    "/"
    TokenizerRegularExpressionFlags:flags
    {$$ = BodyAndFlags(body, flags);};

TokenizerRegularExpressionBody:String =
    !"*"
    {$$ = u"";}
    (
        TokenizerRegularExpressionChar:value
        {$$ += value;}
    )+;

TokenizerRegularExpressionChar:String =
    ![\\/[]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    / TokenizerRegularExpressionClass:classValue
    {$$ = classValue;}
    ;

TokenizerRegularExpressionBackslashSequence:String =
    "\\"
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"\\", nonTerminator);}
    ;

TokenizerRegularExpressionClass:String =
    "["
    {$$ = u"[";}
    (
        TokenizerRegularExpressionClassChar:classChar
        {$$ += classChar;}
    )*
    "]"
    {$$ += u"]";}
    ;

TokenizerRegularExpressionClassChar:String =
    ![\\\]]
    !TokenizerLineTerminatorSequence
    [^]:nonTerminator
    {$$ = appendCodePoint(u"", nonTerminator);}
    / TokenizerRegularExpressionBackslashSequence:backslashSequence
    {$$ = backslashSequence;}
    ;

TokenizerRegularExpressionFlags:String =
    {$$ = u"";}
    (
        TokenizerEscapelessIdentifierPart:ch
        {$$ = appendCodePoint(std::move($$), ch);}
        / "\\"
        TokenizerUnicodeEscapeSequence:unicodeEscape
        {$$ += u"\\" + unicodeEscape.raw;}
    )*
    !"\\"
    ;

TokenizerNoSubstitutionTemplate:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateHead:RawAndCookedString =
    "`"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateMiddle:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "${";

TokenizerTemplateTail:RawAndCookedString =
    "}"
    (
        TokenizerTemplateCharacter:value
        {$$.raw += value.raw; $$.cooked += value.cooked;}
    )*
    "`";

TokenizerTemplateCharacter:RawAndCookedString =
    "$"
    !"{"
    {$$ = RawAndCookedString(u"$");}
    / "\\"
    TokenizerEscapeSequence:escapeSequence
    {$$.raw += u"\\" + escapeSequence.raw; $$.cooked += escapeSequence.cooked;}
    / "\\"
    TokenizerLineTerminatorSequence:lineContinuation
    {$$.raw = appendCodePoint(std::move($$.raw) + u"\\", lineContinuation);}
    / TokenizerLineTerminatorSequence:lineTerminator
    {
        $$.raw = appendCodePoint(std::move($$.raw), lineTerminator);
        $$.cooked = appendCodePoint(std::move($$.cooked), lineTerminator);
    }
    / !TokenizerLineTerminatorSequence
    [^`\\$]:ch
    {
        $$.raw = appendCodePoint(std::move($$.raw), ch);
        $$.cooked = appendCodePoint(std::move($$.cooked), ch);
    }
    ;

IdentifierName:String =
    TokenizerTokenSeperator<true>
    TokenizerIdentifierName:value
    {$$ = value;}
    ;

TokenAwait = TokenizerTokenSeperator<true> TokenizerAwait;
TokenBreak = TokenizerTokenSeperator<true> TokenizerBreak;
TokenCase = TokenizerTokenSeperator<true> TokenizerCase;
TokenCatch = TokenizerTokenSeperator<true> TokenizerCatch;
TokenClass = TokenizerTokenSeperator<true> TokenizerClass;
TokenConst = TokenizerTokenSeperator<true> TokenizerConst;
TokenContinue = TokenizerTokenSeperator<true> TokenizerContinue;
TokenDebugger = TokenizerTokenSeperator<true> TokenizerDebugger;
TokenDefault = TokenizerTokenSeperator<true> TokenizerDefault;
TokenDelete = TokenizerTokenSeperator<true> TokenizerDelete;
TokenDo = TokenizerTokenSeperator<true> TokenizerDo;
TokenElse = TokenizerTokenSeperator<true> TokenizerElse;
TokenEnum = TokenizerTokenSeperator<true> TokenizerEnum;
TokenExport = TokenizerTokenSeperator<true> TokenizerExport;
TokenExtends = TokenizerTokenSeperator<true> TokenizerExtends;
TokenFalse = TokenizerTokenSeperator<true> TokenizerFalse;
TokenFinally = TokenizerTokenSeperator<true> TokenizerFinally;
TokenFor = TokenizerTokenSeperator<true> TokenizerFor;
TokenFunction = TokenizerTokenSeperator<true> TokenizerFunction;
TokenIf = TokenizerTokenSeperator<true> TokenizerIf;
TokenImplements = TokenizerTokenSeperator<true> TokenizerImplements;
TokenImport = TokenizerTokenSeperator<true> TokenizerImport;
TokenIn = TokenizerTokenSeperator<true> TokenizerIn;
TokenInstanceOf = TokenizerTokenSeperator<true> TokenizerInstanceOf;
TokenInterface = TokenizerTokenSeperator<true> TokenizerInterface;
TokenNew = TokenizerTokenSeperator<true> TokenizerNew;
TokenNull = TokenizerTokenSeperator<true> TokenizerNull;
TokenPackage = TokenizerTokenSeperator<true> TokenizerPackage;
TokenPrivate = TokenizerTokenSeperator<true> TokenizerPrivate;
TokenProtected = TokenizerTokenSeperator<true> TokenizerProtected;
TokenPublic = TokenizerTokenSeperator<true> TokenizerPublic;
TokenReturn = TokenizerTokenSeperator<true> TokenizerReturn;
TokenSuper = TokenizerTokenSeperator<true> TokenizerSuper;
TokenSwitch = TokenizerTokenSeperator<true> TokenizerSwitch;
TokenThis = TokenizerTokenSeperator<true> TokenizerThis;
TokenThrow = TokenizerTokenSeperator<true> TokenizerThrow;
TokenTrue = TokenizerTokenSeperator<true> TokenizerTrue;
TokenTry = TokenizerTokenSeperator<true> TokenizerTry;
TokenTypeOf = TokenizerTokenSeperator<true> TokenizerTypeOf;
TokenVar = TokenizerTokenSeperator<true> TokenizerVar;
TokenVoid = TokenizerTokenSeperator<true> TokenizerVoid;
TokenWhile = TokenizerTokenSeperator<true> TokenizerWhile;
TokenWith = TokenizerTokenSeperator<true> TokenizerWith;
TokenYield = TokenizerTokenSeperator<true> TokenizerYield;

TokenIdentifier<isModule:bool, isStrict:bool>:String =
    TokenizerTokenSeperator<true>
    !TokenizerReservedWord
    TokenizerIdentifierName:value
    {$$ = value;};

TokenIdentifierOrYield<isModule:bool, isStrict:bool, canHaveYield:bool>:String =
    &{
        if(!canHaveYield)
            $? = "yield not allowed here";
    }
    TokenYield
    {$$ = u"yield";}
    / TokenIdentifier:value
    {$$ = value;}
    ;

PrimaryExpression<isModule:bool, isStrict:bool, canHaveYield:bool>:ExpressionPointer =
    TokenThis {$$ = arena.make<ast::ExpressionThis>($_);}
    ;
